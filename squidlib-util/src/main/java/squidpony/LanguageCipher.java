package squidpony;

import regexodus.*;
import squidpony.squidmath.CrossHash;
import squidpony.squidmath.StatefulRNG;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

/**
 * Class that builds up a dictionary of words in a source text to words generated by a FakeLanguageGen, and can
 * "translate" a source text to a similarly-punctuated, similarly-capitalized fake text. Uses a hash of each word in the
 * source text to determine the RNG seed that FakeLanguageGen will use, so the translation is not random. Can cipher a
 * typically English text and generate a text with FakeLanguageGen, but also decipher such a generated text with a
 * fully-complete, partially-complete, or partially-incorrect vocabulary.
 * @author Tommy Ettinger
 * Created by Tommy Ettinger on 5/1/2016.
 */
public class LanguageCipher implements Serializable{
    public FakeLanguageGen language;
    private StatefulRNG rng;
    // not a LinkedHashMap because this should never be need a random element to be requested
    public HashMap<String, String> table, reverse;
    private static final Pattern wordMatch = Pattern.compile("(\\pL+)|(\\pL[\\pL\\p{Pd}]*\\pL)");

    /**
     * Constructs a LanguageCipher that will generate English-like or Dutch-like text by default.
     */
    public LanguageCipher()
    {
        this(FakeLanguageGen.ENGLISH);
    }

    /**
     * Constructs a LanguageCipher that will use the given style of language generator to produce its text.
     * @param language a FakeLanguageGen, typically one of the static constants in that class or a mix of them.
     */
    public LanguageCipher(FakeLanguageGen language)
    {
        this.language = language.copy();
        rng = new StatefulRNG();
        table = new HashMap<>(512);
        reverse = new HashMap<>(512);
    }

    /**
     * Copies another LanguageCipher and constructs this one with the information in the other. Copies the dictionary
     * of known words, as well as the FakeLanguageGen style and everything else.
     * @param other a previously-constructed LanguageCipher.
     */
    public LanguageCipher(LanguageCipher other)
    {
        this.language = other.language.copy();
        this.rng = new StatefulRNG();
        this.table = new HashMap<>(other.table);
        this.reverse = new HashMap<>(other.reverse);
    }

    /**
     * Given a word in the source language (usually English), looks up an existing translation for that word, or if none
     * exists, generates a new word based on the hash of the source word and this LanguageCipher's FakeLanguageGen.
     * @param source a word in the source language
     * @return a word in the fake language
     */
    public String lookup(String source)
    {
        if(source == null || source.isEmpty())
            return "";
        String s2 = source.toLowerCase(), ciphered;
        if(table.containsKey(s2))
            ciphered = table.get(s2);
        else {
            long h = CrossHash.hash64(s2);
            rng.setState(h);
            ciphered = language.word(rng, false, (int) Math.ceil(s2.length() / (2.2 + rng.nextDouble())));
            table.put(s2, ciphered);
            reverse.put(ciphered, s2);
        }
        char[] chars = ciphered.toCharArray();
        // Lu is the upper case letter category in Unicode; we're using regexodus for this because GWT probably
        // won't respect unicode case data on its own. We are using GWT to capitalize, though. Hope it works...
        if(Category.Lu.contains(source.charAt(0)))
            chars[0] = Character.toUpperCase(chars[0]);
        if(source.length() > 1 && Category.Lu.contains(source.charAt(1))) {
            for (int i = 1; i < chars.length; i++) {
                chars[i] = Character.toUpperCase(chars[i]);
            }
        }
        return new String(chars);
    }

    /**
     * Given a String, StringBuilder, or otherCharSequence that should contain words in the source language, this
     * translates each word to the fake language, using existing translations if previous calls to cipher() or lookup()
     * had translated that word.
     * @param text a CharSequence, such as a String, that contains words in the source language
     * @return a String of the translated text.
     */
    public String cipher(CharSequence text)
    {
        Replacer rep = wordMatch.replacer(new Substitution() {
            @Override
            public void appendSubstitution(MatchResult match, TextBuffer dest) {
                dest.append(lookup(match.group(0)));
            }
        });
        return rep.replace(text);
    }

    /**
     * Deciphers words in an already-ciphered text with a given String-to-String Map for a vocabulary. This Map could be
     * the reverse field of this LanguageCipher, which would give a complete translation, or it could be a
     * partially-complete or partially-correct vocabulary of words the player has learned.
     * @param text a text in the fake language
     * @param vocabulary a Map of Strings in the fake language to Strings in the source language
     * @return a deciphered version of text that has any words as keys in vocabulary translated to the source language
     */
    public String decipher(String text, final Map<String, String> vocabulary)
    {
        Pattern pat;
        Replacer rep;
        StringBuilder sb = new StringBuilder(128);
        sb.append("\\b(?:");
        for(String k : vocabulary.keySet())
        {
            sb.append("(?:\\Q");
            sb.append(k);
            sb.append("\\E)|");
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.append(")\\b");

        pat = Pattern.compile("\\b" + sb + "\\b", "ui");

        rep = pat.replacer(new Substitution() {
            @Override
            public void appendSubstitution(MatchResult match, TextBuffer dest) {
                String translated = match.group(0);
                if(translated == null) {
                    return;
                }
                translated = translated.toLowerCase();
                translated = vocabulary.get(translated);
                if(translated == null) {
                    dest.append(match.group(0));
                    return;
                }
                char[] chars = translated.toCharArray();
                if(Category.Lu.contains(match.charAt(0)))
                    chars[0] = Character.toUpperCase(chars[0]);
                if(match.length() > 1 && Category.Lu.contains(match.charAt(1))) {
                    for (int i = 1; i < chars.length; i++) {
                        chars[i] = Character.toUpperCase(chars[i]);
                    }
                }
                dest.append(chars, 0, chars.length);
            }
        });
        return rep.replace(text);
    }

    /**
     * Adds a translation pair to vocabulary so it can be used in decipher, giving a correct translation for sourceWord.
     * Modifies vocabulary in-place and returns this LanguageCipher for chaining. Can be used to correct a mismatched
     * translation added to vocabulary with mismatchTranslation.
     * @param vocabulary a Map of String keys to String values that will be modified in-place
     * @param sourceWord a word in the source language, typically English; the meaning will be "learned" for decipher
     * @return this, for chaining
     */
    public LanguageCipher learnTranslation(Map<String, String> vocabulary, String sourceWord)
    {
        vocabulary.put(lookup(sourceWord.toLowerCase()), sourceWord);
        return this;
    }

    /**
     * Adds translation pairs to vocabulary so it can be used in decipher, giving a correct translation for sourceWords.
     * Modifies vocabulary in-place and returns this LanguageCipher for chaining. Can be used to correct mismatched
     * translations added to vocabulary with mismatchTranslation.
     * @param vocabulary a Map of String keys to String values that will be modified in-place
     * @param sourceWords an array or vararg of words in the source language, typically English; their meanings will
     *                    be "learned" for decipher
     * @return this, for chaining
     */
    public LanguageCipher learnTranslations(Map<String, String> vocabulary, String... sourceWords)
    {
        for (int i = 0; i < sourceWords.length; i++) {
            learnTranslation(vocabulary, sourceWords[i]);
        }
        return this;
    }

    /**
     * Adds translation pairs to vocabulary so it can be used in decipher, giving a correct translation for sourceWords.
     * Modifies vocabulary in-place and returns this LanguageCipher for chaining. Can be used to correct mismatched
     * translations added to vocabulary with mismatchTranslation.
     * @param vocabulary a Map of String keys to String values that will be modified in-place
     * @param sourceWords an Iterable of words in the source language, typically English; their meanings will be
     *                   "learned" for decipher
     * @return this, for chaining
     */
    public LanguageCipher learnTranslations(Map<String, String> vocabulary, Iterable<String> sourceWords)
    {
        for (String s : sourceWords) {
            learnTranslation(vocabulary, s);
        }
        return this;
    }

    /**
     * Adds a translation pair to vocabulary so it can be used in decipher, giving a typically-incorrect translation for
     * correctWord where it provides mismatchWord instead when the ciphered version of correctWord appears.
     * Modifies vocabulary in-place and returns this LanguageCipher for chaining. You can use learnTranslation() to
     * correct a mismatched vocabulary word, or mismatchTranslation() again to change the mismatched word.
     * @param vocabulary a Map of String keys to String values that will be modified in-place
     * @param correctWord a word in the source language, typically English; where the ciphered version of this
     *                    appears and the text is deciphered, mismatchWord will be used instead
     * @param mismatchWord a String that will be used for deciphering in place of the translation of correctWord.
     * @return this, for chaining
     */
    public LanguageCipher mismatchTranslation(Map<String, String> vocabulary, String correctWord, String mismatchWord)
    {
        vocabulary.put(lookup(correctWord.toLowerCase()), mismatchWord);
        return this;
    }
}
