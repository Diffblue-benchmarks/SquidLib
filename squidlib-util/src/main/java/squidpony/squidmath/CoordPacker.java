package squidpony.squidmath;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;


/**
 * Provides static methods to encode Coords as single primitive ints in various ways, hence the namesake, but also
 * provides advanced methods to encode 2D arrays of various sorts produced by SquidLib in extremely memory-efficient
 * representations, and decode those representations to various types of 2D array on-demand.
 *<br>
 * NOTE: This class is atypically complex and low-level for SquidLib because it is attempting to attain some very
 * challenging performance gains. You should not consider it idiomatic SquidLib code or start modifying it unless
 * you have a good grasp of bitwise operations and the performance implications, particularly in regard to memory
 * consumption, that higher-level and more convenient Java programming techniques have.
 *<br>
 * The pack() methods in this class take a 2D array with a clear division between cells in an "on" state and cells in an
 * "off" state, and they produce a very tightly compressed short array that can be losslessly decompressed with the
 * unpack() methods to a boolean 2D array that stores equivalent on/off data to the input. The packMulti() method in
 * this class takes a double 2D array that has more than two states that may need to be encoded, such as an FOV map that
 * stores light level as a value between 0.0 and 1.0 instead of just on or off, and an additional double array that
 * defines what states should be distinguished in the result (for example, if the FOV can store values that differ by
 * 0.1 for a FOV radius of 10, you could pass the array of 10 levels: 0.1, 0.2, 0.3, ... 0.9, 1.0). The value returned
 * by packMulti() is a short[][], but with different array lengths for each sub-array (a jagged array); the length of
 * the short[][] is the same as the length of the levels array, and each sub-array corresponds to a different level of
 * FOV lighting or other gradation as defined in levels. This short[][] can be passed to the unpackMultiByte() method in
 * this class to produce a byte 2D array where the original levels correspond to progressively greater bytes, with 0
 * used for cells that were less than the smallest value in levels, 1 for values that were only greater than the
 * smallest value, and no others, in levels, then 2 for larger values, etc. until it places a byte with a value equal to
 * the length of levels in the cells that are the highest. There is also the unpackMultiDouble() method in this class
 * that takes the same short[][] unpackMultiByte() can take, but also takes a levels double array that should be the
 * same as the one used to compress short[][]. It will return a double 2D array with any cells that were smaller than
 * the smallest value in levels assigned 0.0, and any other cells will be assigned a double that corresponds to the
 * highest value in levels that does not exceed the original double at that location in the unpacked data. To make this
 * more clear, if you have 4 levels: [0.25, 0.5, 0.75, 1.0] and you packMulti() on an FOV with a large radius and
 * sample values 0.1, 0.45, 0.8, 1.0, you will get a packed short[][] with 4 sub-arrays to match the 4 levels. If you
 * then pass the short[][] and levels to unpackMultiDouble later, much of the same radius will be filled, but because
 * the sample value 0.1 was less than the smallest value in levels, its cell will be given 0.0. What was originally 0.45
 * will be given the next-lower levels value, 0.25; 0.8 will be given 0.75, and 1.0 will remain 1.0.
 *<br>
 * This compression is meant to produce a short[] or short[][] that uses as little memory as possible for the specific
 * case of compressing maps with these qualities:
 * <ul>
 *     <li>Maps are not especially large for a grid-based game; the maximum size is 256x256 cells.</li>
 *     <li>The vast majority of that 256x256 space is either unused or filled with cells no greater than 0.</li>
 *     <li>The cells that are greater than 0 are mostly near each other, though separate areas are possible.</li>
 * </ul>
 * These properties are all shared by typical roguelike FOV maps, and the specificity of these circumstances mean
 * extraordinarily dense compression can be achieved using the right combination of algorithms. In early testing,
 * using dungeon maps generated by {@link squidpony.squidgrid.mapping.DungeonGenerator} that should be typical of
 * roguelike maps and a diamond-shaped FOV with radius 8, compression of the short[] returned by pack() vs.
 * the original double[][] (which wastefully represents 2 states with 8 bytes) yields average memory usage ratios
 * between (with relatively optimal parameters) 0.0001237905030818498 in one of the best cases, and (with some very
 * poor parameters for the dungeon, but still using a realistic FOV map) 0.003135985198889917 in one of the worst.
 *<br>
 * This table shows the results for the average of 100 runs of pack() in a map with a "good size" and 100 runs in a map
 * with a "bad size." Both the compression ratio vs. a double[][] that stores only whether a cell is on or off and a
 * boolean[][] that stores the same information are provided.
 * <table BORDER CELLPADDING=3 CELLSPACING=1>
 *     <caption>Memory Performance of CoordPacker</caption>
 *     <tr>
 *         <th></th>
 *         <th>Bytes of RAM used, double 2D array</th>
 *         <th>Bytes of RAM used, boolean 2D array</th>
 *         <th>Average Bytes of RAM used, short 1D array (packed)</th>
 *         <th>Compression ratio, packed vs. doubles</th>
 *         <th>Compression ratio, packed vs. booleans</th>
 *     </tr>
 *     <tr>
 *         <td>240x240 dungeon map (good size)</td>
 *         <td>464656</td>
 *         <td>61456</td>
 *         <td>57.52</td>
 *         <td>0.0001237905030818498</td>
 *         <td>0.000935954178599323</td>
 *     </tr>
 *     <tr>
 *         <td>30x70 dungeon map (bad size)</td>
 *         <td>17296</td>
 *         <td>2656</td>
 *         <td>54.24</td>
 *         <td>0.003135985198889917</td>
 *         <td>0.020421686746987953</td>
 *     </tr>
 * </table>
 * In the best-case scenario of packing a 240x240 double array to a short array encoding two states, the result
 * uses less than 1/8000 the memory that the input uses. Writing to disk can store both input and output more
 * efficiently, but the method used here should ensure that even encoding the input FOV map as a flat sequence of
 * single bits and compressing the file should still be on par with the output of pack() due to optimization to
 * ensure nearby cells on a map are compressed together.
 *<br>
 * The technique used by this class is to walk along a Hilbert Curve, storing whether the walk is traveling through
 * "on" or "off" cells, which can be determined by a comparison to a number or a boolean, then encoding alternate shorts
 * into the short[] to be returned, with even-number indices (starting at 0) in the array corresponding to the number of
 * contiguous cells walked through in the "off" state, and odd-number indices corresponding to the number of
 * contiguous cells walked through in the "on" state. A user of this library does not need to understand the details
 * and properties of this algorithm unless they want to generate maps that will compress more optimally. In short:
 * <ul>
 * <li>Smaller maps tend to be processed faster by pack(), since the nature of a Hilbert Curve means a map that
 * fits in one half the width and one half the height of the curve only needs to walk one quarter of the Curve to
 * get all the needed information.</li>
 * <li>Smaller maps also compress less optimally ratio-wise than larger maps with the same area of "on" cells. The
 * compression ratio approaches its best when using very large maps, such as 240x240, and encoding just a few
 * cells on that map (such as for a small FOV radius or a cramped room). A map that is entirely "off" uses only 16
 * bytes of RAM (the minimum for any array on the JVM).</li>
 * <li>Unusually shaped maps can cause compression problems by forcing adjacent cells to sometimes require walking
 * more cells than needed to get to an adjacent cell. For example, a map greater than 64 cells tall, but less than
 * 33 cells wide, has properties that require walking through a large empty area to get to sometimes only a few
 * cells that are "on" before it walks back through empty space. Similarly, a map that is greater than 128 cells
 * tall but is otherwise narrow has the same property of requiring walking through empty space, but also requires
 * the entire Curve to be walked even if the map's width is only a tiny fraction of the Curve's 256 cells.</li>
 * </ul>
 * <b>In shorter-than-short</b>, you'll get particularly good results for compression speed and compressed size with
 * maps approximately these sizes: 240x240, 240x120, 120x120, 60x120, 60x60, 60x30, 30x30. The biggest maps have the
 * best relative gain on compressed memory usage, and the smallest maps have the best compression speed.
 *<br>
 * The details of the algorithm are not terribly complex once you understand the Hilbert Curve. The simplified
 * version of the Hilbert Curve that SquidLib employs is essentially a path through a square grid (it must have side
 * lengths that are powers of 2, and SquidLib always uses 256), starting in the corner cell (x=0,y=0), ending in the
 * corner cell (x=0,y=255), and traversing every other cell on the grid along its path without ever traveling in a
 * loop, crossing the path it walked, or moving in any direction but one cell up, down, left, or right. The shape
 * of the path this takes has the useful property of keeping most groups of cells walked through with similar x and
 * y at similar distances traveled from the start of the curve, and most groups of cells with very dissimilar x and
 * y at very different distances traveled. Since FOV and several other things you might want to encode with CoordPacker
 * tends to be clustered in small areas and occupy more complicated shapes than straight lines due to dungeon layout
 * blocking sections of FOV, the simplest paths of a wide zigzag from side-to-side, or an outward-going-in spiral, have
 * rather poor behavior when determining how much of an area they pass through contiguously. The contiguous area trait
 * is important because of the next step: Run-Length Encoding.
 *<br>
 * Run-Length Encoding is much simpler to explain than the Hilbert Curve, especially without visual aids. In the version
 * SquidLib uses, only on or off states need to be recorded, so the method used here is smaller and more efficient than
 * most methods that need to store repeated characters in strings (and letters, numbers, and punctuation clearly have
 * more than 2 states). The technique works like this:
 *<br>
 * Start in the "off" state, walk down the Hilbert Curve counting how many cells you walk through that are still "off,"
 * and when you encounter a cell that is "on," you write down how many cells were off, transition to the "on" state. Now
 * keep walking the Hilbert Curve, but counting how many cells you walk through that are still "on." When you reach
 * an "off" cell, write down how many were "on," then start walking and counting again, with your count starting at 0.
 * Repeat until you reach the end of the Hilbert Curve, but if you reach the end while counting "off" cells, you don't
 * need to write down that number (a shortcut allows many maps to stop sooner than the 65,536th element of the Curve).
 *<br>
 * There are some additional traits that relate to the edge of the map being treated as "off" even though no
 * calculations are done for cells out of map bounds, and some optimizations that ensure that maps that are smaller than
 * a half, a quarter, or an eighth of the 256x256 curve in both dimensions (and sometimes just one) only need to walk a
 * portion of the Hilbert Curve and simply skip the rest without walking it.
 *<br>
 * The Hilbert Curve has not been definitively proven to be the best possible path to ensure 1D distance and 2D location
 * are similar, but it has been extensively used for tasks that require similar locations for similar distances (in
 * particular, it has become useful in supercomputing clusters for allocating related work to physically nearby
 * machines), and since there hasn't been anything with better spatial properties discovered yet, this technique should
 * remain useful for some time.
 * <br>
 * Created by Tommy Ettinger on 10/1/2015.
 * @author Tommy Ettinger
 */
public class CoordPacker {
    public static final int DEPTH = 8;
    private static final int BITS = DEPTH << 1;

    public static short[] hilbertX = new short[0x10000], hilbertY = new short[0x10000], ALL_WALL = new short[0];
    static {
        ClassLoader cl = CoordPacker.class.getClassLoader();
        InputStream xStream = cl.getResourceAsStream("hilbert/x.bin"),
                    yStream = cl.getResourceAsStream("hilbert/y.bin");
        byte[] xBytes = new byte[0x20000], yBytes = new byte[0x20000];
        try {
            xStream.read(xBytes);
            ByteBuffer.wrap(xBytes).asShortBuffer().get(hilbertX);
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            yStream.read(yBytes);
            ByteBuffer.wrap(yBytes).asShortBuffer().get(hilbertY);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that only stores two
     * relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
     * the {@link CoordPacker} class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
     * relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any double
     * greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
     * as possible for most roguelike FOV maps.
     *<br>
     * <b>To store more than two states</b>, you should use packMulti().
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method.
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static short[] pack(double[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        ShortVLA packing = new ShortVLA(64);
        boolean on = false, current;
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(hilbertX[i] >= xSize || hilbertY[i] >= ySize) {
                if(on) {
                    on = false;
                    packing.add((short) skip);
                    skip = 0;
                }
                continue;
            }
            ml++;
            current = map[hilbertX[i]][hilbertY[i]] > 0.0;
            if(current != on)
            {
                packing.add((short) skip);
                skip = 0;
                on = current;
            }
        }
        if(on)
            packing.add((short)skip);
        if(packing.size == 0)
            return ALL_WALL;
        return packing.shrink();
    }

    /**
     * Compresses a boolean[][], returning a short[] as described in the {@link CoordPacker} class documentation. This
     * short[] can be passed to CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][]
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *
     * @param map a boolean[][] that should ideally be mostly false.
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static short[] pack(boolean[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        ShortVLA packing = new ShortVLA(64);
        boolean on = false, current;
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(hilbertX[i] >= xSize || hilbertY[i] >= ySize) {
                if(on) {
                    on = false;
                    packing.add((short) skip);
                    skip = 0;
                }
                continue;
            }
            ml++;
            current = map[hilbertX[i]][hilbertY[i]];
            if(current != on)
            {
                packing.add((short) skip);
                skip = 0;
                on = current;
            }
        }
        if(on)
            packing.add((short)skip);
        if(packing.size == 0)
            return ALL_WALL;
        return packing.shrink();
    }

    /**
     * Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
     * array that can be passed to packMulti() to ensure that you have the requested number of separate levels in the
     * multi-packed result. For example, if you pass 6 to this method, it will return a length-6 double array, and if
     * you pass that as the levels parameter to packMulti(), then that method will return a length-6 array of short
     * arrays that each encode a region that met a different minimum value in the originally packed double[][].
     * The behavior of this method causes any doubles that are closer to 1.0 / totalLevels than they are to 0.0 to be
     * packed as "on" in at least one of packMulti()'s resultant sub-arrays. This allows Radius.CIRCLE or similar FOV
     * that produces cells with values that aren't evenly distributed between 0.0 and 1.0 to be used without causing an
     * explosion in the number of required levels.
     * <br>
     * <b>This method should not be used to generate levels for unpacking; it is only intended for packing.</b> Use the
     * similar method generateLightLevels() to generate a levels array that is suitable for unpacking FOV.
     * @param totalLevels the number of separate levels to group doubles into
     * @return a double[] suitable as a levels parameter for packMulti()
     */
    public static double[] generatePackingLevels(int totalLevels)
    {
        if (totalLevels > 63 || totalLevels <= 0)
            throw new UnsupportedOperationException(
                    "Bad totalLevels; should be 0 < totalLevels < 64 but was given " +
                            totalLevels);

        double[] levels = new double[totalLevels];
        for (int i = 0; i < totalLevels; i++) {
            levels[i] = 1.0 * i / totalLevels + 0.5 / totalLevels;
        }
        return levels;
    }

    /**
     * Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
     * array that can be passed to unpackMultiDouble() to ensure that the minimum double returned for an "on" cell is
     * 1.0 / totalLevels, and every progressively tighter level in the short[][] being unpacked will be close to a
     * multiple of that minimum double value. This only applies to "on" cells; any cells that did not meet a minimum
     * value when packed will still be 0.0. For example, if you pass 6 to this method, it will return a length-6 double
     * array, and if you pass that as the levels parameter to unpackMultiDouble(), then that method will return a
     * double[][] with no more than totalLevels + 1 used values, ranging from 0.0 to 1.0 with evenly spaced values, all
     * multiples of 1.0 / totalLevels, in between.
     * <br>
     * <b>This method should not be used to generate levels for packing; it is only intended for unpacking.</b> Use the
     * similar method generatePackingLevels() to generate a levels array that is suitable for packing double[][] values.
     * @param totalLevels the number of separate levels to assign doubles; this MUST match the size of the levels
     *                    parameter used to pack a double[][] with packMulti() if this is used to unpack that data
     * @return a double[] suitable as a levels parameter for unpackMultiDouble()
     */
    public static double[] generateLightLevels(int totalLevels)
    {
        if (totalLevels > 63 || totalLevels <= 0)
            throw new UnsupportedOperationException(
                    "Bad totalLevels; should be 0 < totalLevels < 64 but was given " +
                            totalLevels);

        double[] levels = new double[totalLevels];
        for (int i = 0; i < totalLevels; i++) {
            levels[i] = 1.0 * (i + 1.0) / totalLevels;
        }
        return levels;
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that stores any number of
     * states and a double[] storing up to 63 states, ordered from lowest to highest, returning a short[][] as described
     * in the {@link CoordPacker} class documentation. This short[][] can be passed to CoordPacker.unpackMultiDouble()
     * to restore the state at a position to the nearest state in levels, rounded down, and return a double[][] that
     * should preserve the states as closely as intended for most purposes. <b>For compressing FOV, you should generate
     * levels with CoordPacker.generatePackingLevels()</b> instead of manually creating the array, because some
     * imprecision is inherent in floating point math and comparisons are often incorrect between FOV with multiple
     * levels and exact levels generated as simply as possible. generatePackingLevels() adds a small correction to the
     * levels to compensate for floating-point math issues, which shouldn't affect the correctness of the results for
     * FOV radii under 100.
     *<br>
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *<br>
     * <b>To store only two states</b>, you should use pack(), unless the double[][] divides data into on and off based
     * on a relationship to some number other than 0.0. To (probably poorly) pack all the walls (and any cells with
     * values higher than DijkstraMap.WALL) in a DijkstraMap's 2D array of doubles called dijkstraArray, you could call
     * <code>packMulti(dijkstraArray, new double[]{DijkstraMap.WALL});</code>
     * Then, you would use only the one sub-element of the returned short[][].
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method unless you have very specific needs.
     * @param levels a double[] starting with the lowest value that should be counted as "on" (the outermost cells of
     *               an FOV map that has multiple grades of brightness would be counted by this) and ascending until the
     *               last value; the last value should be highest (commonly 1.0 for FOV), and will be used for any cells
     *               higher than all the other levels values. An example is an array of: 0.25, 0.5, 0.75, 1.0
     * @return a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
     *               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
     *               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
     *               lengths by the end of the short[][].
     */
    public static short[][] packMulti(double[][] map, double[] levels) {
        if (levels == null || levels.length == 0)
            throw new UnsupportedOperationException("Must be given at least one level");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to efficiently pack; should be less than 64 but was given " +
                            levels.length);
        if (map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packMulti() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if (xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        int limit = 0x10000, llen = levels.length, mapLimit = xSize * ySize;
        long on = 0, current = 0;
        ShortVLA[] packing = new ShortVLA[llen];
        int[] skip = new int[llen];

        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short[][] packed = new short[llen][];
        for(int l = 0; l < llen; l++) {
            packing[l] = new ShortVLA(64);
            for (int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip[l]++) {
                if (hilbertX[i] >= xSize || hilbertY[i] >= ySize) {
                    if ((on & (1L << l)) != 0L) {
                        on ^= (1L << l);
                        packing[l].add((short) skip[l]);
                        skip[l] = 0;
                    }
                    continue;
                }
                ml++;
                // sets the bit at position l in current to 1 if the following is true, 0 if it is false:
                //     map[hilbertX[i]][hilbertY[i]] > levels[l]
                // looks more complicated than it is.
                current ^= ((map[hilbertX[i]][hilbertY[i]] > levels[l] ? -1 : 0) ^ current) & (1 << l);
                if (((current >> l) & 1L) != ((on >> l) & 1L)) {
                    packing[l].add((short) skip[l]);
                    skip[l] = 0;
                    on = current;

                    // sets the bit at position l in on to the same as the bit at position l in current.
                    on ^= (-((current >> l) & 1L) ^ on) & (1L << l);

                }
            }

            if (((on >> l) & 1L) == 1L)
                packing[l].add((short) skip[l]);
            if(packing[l].size == 0)
                packed[l] = ALL_WALL;
            else
                packed[l] = packing[l].shrink();
        }
        return packed;
    }

    /**
     * Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
     * the {@link CoordPacker} class documentation. This returns a boolean[][] that stores the same values that were
     * packed if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
     * boolean[][] this returns will have true for all values greater than 0 and false for all others. If this is one
     * of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
     * array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
     * true, while all others will be false. Width and height do not technically need to match the dimensions of the
     * original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[] encoded by calling one of this class' packing methods on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a boolean[][] storing which cells encoded by packed are on (true) or off (false).
     */
    public static boolean[][] unpack(short[] packed, int width, int height)
    {
        if(packed == null)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.unpack() must be given a non-null array");
        boolean[][] unpacked = new boolean[width][height];
        if(packed.length == 0)
            return unpacked;
        boolean on = false;
        int idx = 0;
        for(int p = 0; p < packed.length; p++, on = !on) {
            if (on) {
                for (int toSkip = idx +(packed[p] & 0xffff); idx < toSkip; idx++) {
                    unpacked[hilbertX[idx]][hilbertY[idx]] = true;
                }
            } else {
                idx += packed[p] & 0xffff;
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
     * using the given levels double[] as the values to assign, as described in the {@link CoordPacker} class
     * documentation. The length of levels and the length of the outer array of packed must be equal. However, the
     * levels array passed to this method should not be identical to the levels array passed to packMulti(); for FOV
     * compression, you should get an array for levels using generatePackingLevels(), but for decompression, you should
     * create levels using generateLightLevels(), which should more appropriately fit the desired output. Reusing the
     * levels array used to pack the FOV will usually produce values at the edge of FOV that are less than 0.01 but
     * greater than 0, and will have a maximum value somewhat less than 1.0; neither are usually desirable, but using a
     * different array made with generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at
     * the highest. Width and height do not technically need to match the dimensions of the original 2D array, but under
     * most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @param levels a double[] that must have the same length as packed, and will be used to assign cells in the
     *               returned double[][] based on what levels parameter was used to compress packed
     * @return a double[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to the nth value in the levels parameter passed to this method.
     */
    public static double[][] unpackMultiDouble(short[][] packed, int width, int height, double[] levels)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiDouble() must be given a non-empty array");
        if (levels == null || levels.length != packed.length)
            throw new UnsupportedOperationException("The lengths of packed and levels must be equal");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to be packed by CoordPacker; should be less than 64 but was given " +
                            levels.length);
        double[][] unpacked = new double[width][height];
        for(int l = 0; l < packed.length; l++) {
            boolean on = false;
            int idx = 0;
            for (int p = 0; p < packed[l].length; p++, on = !on) {
                if (on) {
                    for (int toSkip = idx + (packed[l][p] & 0xffff); idx < toSkip; idx++) {
                        unpacked[hilbertX[idx]][hilbertY[idx]] = levels[l];
                    }
                } else {
                    idx += packed[l][p] & 0xffff;
                }
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces a simple 2D array where the values are bytes
     * corresponding to 1 + the highest index into levels (that is, the original levels parameter passed to packMulti)
     * matched by a cell, or 0 if the cell didn't match any levels during compression, as described in the
     * {@link CoordPacker} class documentation. Width and height do not technically need to match the dimensions of
     * the original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a byte[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to bytes with the value n+1, or 0 if they were "off" in the original array.
     */
    public static byte[][] unpackMultiByte(short[][] packed, int width, int height)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiByte() must be given a non-empty array");
        byte[][] unpacked = new byte[width][height];
        byte lPlus = 1;
        for(int l = 0; l < packed.length; l++, lPlus++) {
            boolean on = false;
            int idx = 0;
            for (int p = 0; p < packed[l].length; p++, on = !on) {
                if (on) {
                    for (int toSkip = idx + (packed[l][p] & 0xffff); idx < toSkip; idx++) {
                        unpacked[hilbertX[idx]][hilbertY[idx]] = lPlus;
                    }
                } else {
                    idx += packed[l][p] & 0xffff;
                }
            }
        }
        return unpacked;
    }

    /**
     * Quickly determines if an x,y position is true or false in the given packed array, without unpacking it.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @param x between 0 and 255, inclusive
     * @param y between 0 and 255, inclusive
     * @return true if the packed data stores true at the given x,y location, or false in any other case.
     */
    public static boolean queryPacked(short[] packed, int x, int y)
    {
        int hilbertDistance = posToHilbert(x, y), total = 0;
        boolean on = false;
        for(int p = 0; p < packed.length; p++, on = !on)
        {
            total += packed[p] & 0xffff;
            if(hilbertDistance < total)
                return on;
        }
        return false;
    }

    /**
     * Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as a Coord[].
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @return a Coord[], ordered by distance along the Hilbert Curve, corresponding to all "on" cells in packed.
     */
    public static Coord[] allPacked(short[] packed)
    {
        ShortVLA vla = new ShortVLA(64);
        boolean on = false;
        int idx = 0;
        for(int p = 0; p < packed.length; p++, on = !on) {
            if (on) {
                vla.addRange(idx, idx + (packed[p] & 0xffff));
            }
            idx += packed[p] & 0xffff;
        }
        short[] distances = vla.shrink();
        Coord[] cs = new Coord[distances.length];
        for (int i = 0; i < distances.length; i++) {
            cs[i] = Coord.get(hilbertX[distances[i]], hilbertY[distances[i]]);
        }
        return cs;
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that only stores two
     * relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
     * the {@link CoordPacker} class documentation. This short[] can be passed to CoordPacker.unpackZ() to restore the
     * relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any double
     * greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
     * as possible for most roguelike FOV maps.
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     * <br>
     * <b>To store more than two states</b>, you should use packMultiZ().
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method.
     * @return a packed short[] that should, in most circumstances, be passed to unpackZ() when it needs to be used.
     */
    public static short[] packZ(double[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packZ() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        ShortVLA packing = new ShortVLA(64);
        boolean on = false, current;
        int skip = 0, limit = 0x10000;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (ySize <= 64) {
                    limit >>= 1;
                    if (xSize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short x, y;
        for(int i = 0; i < limit; i++, skip++)
        {
            x = zDecodeX(i);
            y = zDecodeY(i);
            if(x >= xSize || y >= ySize) {
                if(on) {
                    on = false;
                    packing.add((short) skip);
                    skip = 0;
                }
                continue;
            }
            current = map[x][y] > 0.0;
            if(current != on)
            {
                packing.add((short) skip);
                skip = 0;
                on = current;
            }
        }
        if(on)
            packing.add((short)skip);
        return packing.shrink();
    }

    /**
     * Compresses a boolean[][], returning a short[] as described in the {@link CoordPacker} class documentation. This
     * short[] can be passed to CoordPacker.unpackZ() to restore the boolean[][]. As stated in the class documentation,
     * the compressed result is intended to use as little memory as possible for most roguelike FOV maps.
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     * <br>
     * <b>To store more than two states</b>, you should use packMultiZ().
     *
     * @param map a boolean[][] that should be mostly false.
     * @return a packed short[] that should, in most circumstances, be passed to unpackZ() when it needs to be used.
     */
    public static short[] packZ(boolean[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packZ() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        ShortVLA packing = new ShortVLA(64);
        boolean on = false, current;
        int skip = 0, limit = 0x10000;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (ySize <= 64) {
                    limit >>= 1;
                    if (xSize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short x, y;
        for(int i = 0; i < limit; i++, skip++)
        {
            x = zDecodeX(i);
            y = zDecodeY(i);
            if(x >= xSize || y >= ySize) {
                if(on) {
                    on = false;
                    packing.add((short) skip);
                    skip = 0;
                }
                continue;
            }
            current = map[x][y];
            if(current != on)
            {
                packing.add((short) skip);
                skip = 0;
                on = current;
            }
        }
        if(on)
            packing.add((short)skip);
        return packing.shrink();
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that stores any number of
     * states and a double[] storing up to 63 states, ordered from lowest to highest, returning a short[][] as described
     * in the {@link CoordPacker} class documentation. This short[][] can be passed to CoordPacker.unpackMultiDoubleZ()
     * to restore the state at a position to the nearest state in levels, rounded down, and return a double[][] that
     * should preserve the states as closely as intended for most purposes.
     *<br>
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *<br>
     * <b>To store only two states</b>, you should use packZ(), unless the double[][] divides data into on and off based
     * on a relationship to some number other than 0.0. To (probably poorly?) pack all the walls (and any cells with
     * values higher than DijkstraMap.WALL) in a DijkstraMap's 2D array of doubles called dijkstraArray, you could call
     * <code>packMulti(dijkstraArray, new double[]{DijkstraMap.WALL});</code>
     * Then, you would use only the one sub-element of the returned short[][].
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method unless you have very specific needs.
     * @param levels a double[] starting with the lowest value that should be counted as "on" (the outermost cells of
     *               an FOV map that has multiple grades of brightness would be counted by this) and ascending until the
     *               last value; the last value should be highest (commonly 1.0 for FOV), and will be used for any cells
     *               higher than all the other levels values. An example is an array of: 0.25, 0.5, 0.75, 1.0
     * @return a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
     *               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
     *               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
     *               lengths by the end of the short[][].
     */
    public static short[][] packMultiZ(double[][] map, double[] levels) {
        if (levels == null || levels.length == 0)
            throw new UnsupportedOperationException("Must be given at least one level");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to efficiently pack; should be less than 64 but was given " +
                            levels.length);
        if (map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packMultiZ() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if (xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        int limit = 0x10000, llen = levels.length;
        long on = 0, current = 0;
        ShortVLA[] packing = new ShortVLA[llen];
        int[] skip = new int[llen];

        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (ySize <= 64) {
                    limit >>= 1;
                    if (xSize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short[][] packed = new short[llen][];
        short x, y;
        for(int l = 0; l < llen; l++) {
            packing[l] = new ShortVLA(64);
            for (int i = 0; i < limit; i++, skip[l]++) {
                x = zDecodeX(i);
                y = zDecodeY(i);
                if (x >= xSize || y >= ySize) {
                    if ((on & (1L << l)) != 0L) {
                        on ^= (1L << l);
                        packing[l].add((short) skip[l]);
                        skip[l] = 0;
                    }
                    continue;
                }
                // sets the bit at position l in current to 1 if the following is true, 0 if it is false:
                //     map[x][y] >= levels[l]
                // looks more complicated than it is.
                current ^= ((map[x][y] >= levels[l] ? -1 : 0) ^ current) & (1 << l);
                if (((current >> l) & 1L) != ((on >> l) & 1L)) {
                    packing[l].add((short) skip[l]);
                    skip[l] = 0;
                    on = current;

                    // sets the bit at position l in on to the same as the bit at position l in current.
                    on ^= (-((current >> l) & 1L) ^ on) & (1L << l);

                }
            }

            if (((on >> l) & 1L) == 1L)
                packing[l].add((short) skip[l]);
            packed[l] = packing[l].shrink();
        }
        return packed;
    }

    /**
     * Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
     * the {@link CoordPacker} class documentation. This returns a boolean[][] that stores the same values that were
     * packed if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
     * boolean[][] this returns will have true for all values greater than 0 and false for all others. If this is one
     * of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
     * array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
     * true, while all others will be false. Width and height do not technically need to match the dimensions of the
     * original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     *
     * @param packed a short[] encoded by calling one of this class' packing methods (Z variant) on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a boolean[][] storing which cells encoded by packed are on (true) or off (false).
     */
    public static boolean[][] unpackZ(short[] packed, int width, int height)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.unpackZ() must be given a non-empty array");
        boolean[][] unpacked = new boolean[width][height];
        boolean on = false;
        int idx = 0;
        for(int p = 0; p < packed.length; p++, on = !on) {
            if (on) {
                for (int toSkip = idx +(packed[p] & 0xffff); idx < toSkip; idx++) {
                    unpacked[zDecodeX(idx)][zDecodeY(idx)] = true;
                }
            } else {
                idx += packed[p] & 0xffff;
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
     * using the given levels double[] as the values to assign, as described in the {@link CoordPacker} class
     * documentation. The length of levels and the length of the outer array of packed must be equal. However, the
     * levels array passed to this method does not have to be identical to the levels array passed to packMulti(); this
     * could be used to pack numbers in grades of 0.25, 0.5, 0.75, 1.0, and unpack it with a different levels array to
     * get numbers that translate packed values of 0.25 to -1.0, 0.5 to -2.0, 0.75 to -3.0, and 1.0 to -999.0. Width and
     * height do not technically need to match the dimensions of the original 2D array, but under most circumstances
     * where they don't match, the data produced will be junk.
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     *
     * @param packed a short[][] encoded by calling this class' packMultiZ() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @param levels a double[] that must have the same length as packed, and will be used to assign cells in the
     *               returned double[][] based on what levels parameter was used to compress packed
     * @return a double[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to the nth value in the levels parameter passed to this method.
     */
    public static double[][] unpackMultiDoubleZ(short[][] packed, int width, int height, double[] levels)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiDoubleZ() must be given a non-empty array");
        if (levels == null || levels.length != packed.length)
            throw new UnsupportedOperationException("The lengths of packed and levels must be equal");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to be packed by CoordPacker; should be less than 64 but was given " +
                            levels.length);
        double[][] unpacked = new double[width][height];
        for(int l = 0; l < packed.length; l++) {
            boolean on = false;
            int idx = 0;
            for (int p = 0; p < packed[l].length; p++, on = !on) {
                if (on) {
                    for (int toSkip = idx + (packed[l][p] & 0xffff); idx < toSkip; idx++) {
                        unpacked[zDecodeX(idx)][zDecodeY(idx)] = levels[l];
                    }
                } else {
                    idx += packed[l][p] & 0xffff;
                }
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces a simple 2D array where the values are bytes
     * corresponding to the highest levels index (in the original levels parameter passed to packMulti) matched by a
     * cell, or 0 if the cell didn't match any levels during compression, as described in the {@link CoordPacker} class
     * documentation. Width and height do not technically need to match the dimensions of the original 2D array, but
     * under most circumstances where they don't match, the data produced will be junk.
     * <br>
     * This uses Z-Coding instead of Hilbert Curves, which may provide suitable compression while requiring less of a
     * constant memory cost for the lookup tables that the Hilbert Curves need to perform quickly.
     *
     * @param packed a short[][] encoded by calling this class' packMultiZ() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a byte[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to bytes with the value n+1, or 0 if they were "off" in the original array.
     */
    public static byte[][] unpackMultiByteZ(short[][] packed, int width, int height)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiByteZ() must be given a non-empty array");
        byte[][] unpacked = new byte[width][height];
        byte lPlus = 1;
        for(int l = 0; l < packed.length; l++, lPlus++) {
            boolean on = false;
            int idx = 0;
            for (int p = 0; p < packed[l].length; p++, on = !on) {
                if (on) {
                    for (int toSkip = idx + (packed[l][p] & 0xffff); idx < toSkip; idx++) {
                        unpacked[zDecodeX(idx)][zDecodeY(idx)] = lPlus;
                    }
                } else {
                    idx += packed[l][p] & 0xffff;
                }
            }
        }
        return unpacked;
    }


    /**
     * Encode a number n as a Gray code; Gray codes have a relation to the Hilbert curve and may be useful.
     * Source: http://xn--2-umb.com/15/hilbert , http://aggregate.org/MAGIC/#Gray%20Code%20Conversion
     * @param n
     * @return
     */
    public static int grayEncode(int n){
        return n ^ (n >> 1);
    }

    /**
     * Decode a number from a Gray code n; Gray codes have a relation to the Hilbert curve and may be useful.
     * Source: http://xn--2-umb.com/15/hilbert , http://aggregate.org/MAGIC/#Gray%20Code%20Conversion
     * @param n
     * @return
     */
    public static int grayDecode(int n) {
        int p = n;
        while ((n >>= 1) != 0)
            p ^= n;
        return p;
    }

    /**
     * Not currently used, may be used in the future.
     * Source: https://www.cs.dal.ca/research/techreports/cs-2006-07 ; algorithm provided in pseudocode
     * @param n
     * @param mask
     * @param i
     * @return
     */
    public static int grayCodeRank(int n, int mask, int i)
    {
        int r = 0;
        for (int k = n - 1; k >= 0; k--)
        {
            if(((mask >> k) & 1) == 1)
                r = (r << 1) | ((i >> k) & 1);
        }
        return  r;
    }

    /**
     *
     * Source: https://www.cs.dal.ca/research/techreports/cs-2006-07 ; algorithm provided in pseudocode
     * @param n
     * @param mask
     * @param altMask
     * @param rank
     * @return
     */
    public static int grayCodeRankInverse(int n, int mask, int altMask, int rank)
    {
        int i = 0, g = 0, j = Integer.bitCount(mask) - 1;
        for(int k = n - 1; k >= 0; k--)
        {
            if(((mask >> k) & 1) == 1)
            {
                i ^= (-((rank >> j) & 1) ^ i) & (1 << k);
                g ^= (-((((i >> k) & 1) + ((i >> k) & 1)) % 2) ^ g) & (1 << k);
                --j;
            }
            else
            {
                g ^= (-((altMask >> k) & 1) ^ g) & (1 << k);
                i ^= (-((((g >> k) & 1) + ((i >> (k+1)) & 1)) % 2) ^ i) & (1 << k);
            }
        }
        return  i;
    }

    /**
     * Takes an x, y position and returns the length to travel along the 256x256 Hilbert curve to reach that position.
     * This assumes x and y are between 0 and 255, inclusive.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param x between 0 and 255 inclusive
     * @param y between 0 and 255 inclusive
     * @return the distance to travel along the 256x256 Hilbert Curve to get to the given x, y point.
     */
    public static int posToHilbert( final int x, final int y )
    {
        int hilbert = 0, remap = 0xb4, mcode, hcode;
        /*
        while( block > 0 )
        {
            --block;
            mcode = ( ( x >> block ) & 1 ) | ( ( ( y >> ( block ) ) & 1 ) << 1);
            hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
            remap ^= ( 0x82000028 >> ( hcode << 3 ) );
            hilbert = ( ( hilbert << 2 ) + hcode );
        }
         */

        mcode = ( ( x >> 7 ) & 1 ) | ( ( ( y >> ( 7 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 6 ) & 1 ) | ( ( ( y >> ( 6 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 5 ) & 1 ) | ( ( ( y >> ( 5 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 4 ) & 1 ) | ( ( ( y >> ( 4 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 3 ) & 1 ) | ( ( ( y >> ( 3 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 2 ) & 1 ) | ( ( ( y >> ( 2 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( ( x >> 1 ) & 1 ) | ( ( ( y >> ( 1 ) ) & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
        remap ^= ( 0x82000028 >> ( hcode << 3 ) );
        hilbert = ( ( hilbert << 2 ) + hcode );

        mcode = ( x & 1 ) | ( ( y & 1 ) << 1);
        hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );

        hilbert = ( ( hilbert << 2 ) + hcode );

        return hilbert;
    }
    /**
     * Takes a position as a Morton code, with interleaved x and y bits and x in the least significant bit, and returns
     * the length to travel along the 256x256 Hilbert curve to reach that position.
     * This uses 16 bits of the Morton code and requires that the code is non-negative.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param morton a Morton code that interleaves two 8-bit unsigned numbers, with x as index1 and y as index2.
     * @return a distance to travel down the Hilbert Curve to reach the location that can be decoded from morton.
     */
    public static int mortonToHilbert( final int morton )
    {
        int hilbert = 0;
        int remap = 0xb4;
        int block = BITS;
        while( block > 0 )
        {
            block -= 2;
            int mcode = ( ( morton >> block ) & 3 );
            int hcode = ( ( remap >> ( mcode << 1 ) ) & 3 );
            remap ^= ( 0x82000028 >> ( hcode << 3 ) );
            hilbert = ( ( hilbert << 2 ) + hcode );
        }
        return hilbert;
    }

    /**
     * Takes a distance to travel along the 256x256 Hilbert curve and returns a Morton code representing the position
     * in 2D space that corresponds to that point on the Hilbert curve; the Morton code will have interleaved x and y
     * bits and x in the least significant bit. This variant uses a lookup table for the 256x256 Hilbert curve, which
     * should make it faster than calculating the position repeatedly.
     * The parameter hilbert is an int but only 16 unsigned bits are used.
     * @param hilbert a distance to travel down the Hilbert Curve
     * @return a Morton code that stores x and y interleaved; can be converted to a Coord with other methods.
     */

    public static int hilbertToMorton( final int hilbert )
    {
        return mortonEncode(hilbertX[hilbert], hilbertY[hilbert]);
    }

    /**
     * Takes a distance to travel along the 256x256 Hilbert curve and returns a Coord representing the position
     * in 2D space that corresponds to that point on the Hilbert curve. This variant uses a lookup table for the
     * 256x256 Hilbert curve, which should make it faster than calculating the position repeatedly.
     * The parameter hilbert is an int but only 16 unsigned bits are used.
     * @param hilbert a distance to travel down the Hilbert Curve
     * @return a Coord corresponding to the position in 2D space at the given distance down the Hilbert Curve
     */
    public static Coord hilbertToCoord( final int hilbert )
    {
        return Coord.get(hilbertX[hilbert], hilbertY[hilbert]);
    }


    /*
     * Takes a distance to travel along the 256x256 Hilbert curve and returns a Morton code representing the position
     * in 2D space that corresponds to that point on the Hilbert curve; the Morton code will have interleaved x and y
     * bits and x in the least significant bit. This variant does not use a lookup table, and is likely slower.
     * The parameter hilbert is an int but only 16 unsigned bits are used.
     * @param hilbert
     * @return
     */
    /*
    public static int hilbertToMortonNoLUT( final int hilbert )
    {
        int morton = 0;
        int remap = 0xb4;
        int block = BITS;
        while( block > 0 )
        {
            block -= 2;
            int hcode = ( ( hilbert >> block ) & 3 );
            int mcode = ( ( remap >> ( hcode << 1 ) ) & 3 );
            remap ^= ( 0x330000cc >> ( hcode << 3 ) );
            morton = ( ( morton << 2 ) + mcode );
        }
        return morton;
    }
    */
    /*
     * Takes a distance to travel along the 256x256 Hilbert curve and returns a Coord representing the position
     * in 2D space that corresponds to that point on the Hilbert curve. This variant does not use a lookup table,
     * and is likely slower.
     * The parameter hilbert is an int but only 16 unsigned bits are used.
     * @param hilbert
     * @return
     */
    /*
    public static Coord hilbertToCoordNoLUT( final int hilbert )
    {
        int x = 0, y = 0;
        int remap = 0xb4;
        int block = BITS;
        while( block > 0 )
        {
            block -= 2;
            int hcode = ( ( hilbert >> block ) & 3 );
            int mcode = ( ( remap >> ( hcode << 1 ) ) & 3 );
            remap ^= ( 0x330000cc >> ( hcode << 3 ) );
            x = (x << 1) + (mcode & 1);
            y = (y << 1) + ((mcode & 2) >> 1);
        }
        return Coord.get(x, y);
    }
    */
    /**
     * Takes a position as a Coord called pt and returns the length to travel along the 256x256 Hilbert curve to reach
     * that position.
     * This assumes pt.x and pt.y are between 0 and 255, inclusive.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param pt
     * @return
     */
    public static int coordToHilbert(final Coord pt)
    {
        return posToHilbert(pt.x, pt.y);
    }
    /**
     * Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
     * index2 bits and index1 in the least significant bit. With this method, index1 and index2 can have up to 8 bits.
     * This returns a 16-bit Morton code and WILL encode information in the sign bit if the inputs are large enough.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param index1 a non-negative integer using at most 8 bits, to be placed in the "x" slots
     * @param index2 a non-negative integer using at most 8 bits, to be placed in the "y" slots
     * @return a Morton code/Z-Code that interleaves the two numbers into one 16-bit short
     */
    public static short zEncode(short index1, short index2)
    { // pack 2 8-bit (unsigned) indices into a 16-bit (signed...) Morton code/Z-Code
        index1 &= 0x000000ff;
        index2 &= 0x000000ff;
        index1 |= ( index1 << 4 );
        index2 |= ( index2 << 4 );
        index1 &= 0x00000f0f;
        index2 &= 0x00000f0f;
        index1 |= ( index1 << 2 );
        index2 |= ( index2 << 2 );
        index1 &= 0x00003333;
        index2 &= 0x00003333;
        index1 |= ( index1 << 1 );
        index2 |= ( index2 << 1 );
        index1 &= 0x00005555;
        index2 &= 0x00005555;
        return (short)(index1 | ( index2 << 1 ));
    }
    /**
     * Takes two 8-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
     * index2 bits and index1 in the least significant bit. With this method, index1 and index2 can have up to 8 bits.
     * This returns a 32-bit Morton code but only uses 16 bits, and will not encode information in the sign bit.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param index1 a non-negative integer using at most 8 bits, to be placed in the "x" slots
     * @param index2 a non-negative integer using at most 8 bits, to be placed in the "y" slots
     * @return a Morton code that interleaves the two numbers as one 32-bit int, but only in 16 bits of it
     */
    public static int mortonEncode(int index1, int index2)
    { // pack 2 8-bit (unsigned) indices into a 32-bit (signed...) Morton code
        index1 &= 0x000000ff;
        index2 &= 0x000000ff;
        index1 |= ( index1 << 4 );
        index2 |= ( index2 << 4 );
        index1 &= 0x00000f0f;
        index2 &= 0x00000f0f;
        index1 |= ( index1 << 2 );
        index2 |= ( index2 << 2 );
        index1 &= 0x00003333;
        index2 &= 0x00003333;
        index1 |= ( index1 << 1 );
        index2 |= ( index2 << 1 );
        index1 &= 0x00005555;
        index2 &= 0x00005555;
        return index1 | ( index2 << 1 );
    }
    /**
     * Takes two 16-bit unsigned integers index1 and index2, and returns a Morton code, with interleaved index1 and
     * index2 bits and index1 in the least significant bit. With this method, index1 and index2 can have up to 16 bits.
     * This returns a 32-bit Morton code and may encode information in the sign bit.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param index1 a non-negative integer using at most 16 bits, to be placed in the "x" slots
     * @param index2 a non-negative integer using at most 16 bits, to be placed in the "y" slots
     * @return a Morton code that interleaves the two numbers as one 32-bit int
     */
    public static int mortonEncode16(int index1, int index2)
    { // pack 2 16-bit indices into a 32-bit Morton code
        index1 &= 0x0000ffff;
        index2 &= 0x0000ffff;
        index1 |= ( index1 << 8 );
        index2 |= ( index2 << 8 );
        index1 &= 0x00ff00ff;
        index2 &= 0x00ff00ff;
        index1 |= ( index1 << 4 );
        index2 |= ( index2 << 4 );
        index1 &= 0x0f0f0f0f;
        index2 &= 0x0f0f0f0f;
        index1 |= ( index1 << 2 );
        index2 |= ( index2 << 2 );
        index1 &= 0x33333333;
        index2 &= 0x33333333;
        index1 |= ( index1 << 1 );
        index2 |= ( index2 << 1 );
        index1 &= 0x55555555;
        index2 &= 0x55555555;
        return index1 | ( index2 << 1 );
    }

    /**
     * Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the short
     * representing the x position.
     * This uses 16 bits of the 32-bit Morton code/Z-Code.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param morton A Morton code or Z-Code that interleaves two 8-bit numbers
     * @return A short that represents the x position extracted from the Morton code/Z-Code
     */
    public static short zDecodeX( final int morton )
    { // unpack the 8-bit (unsigned) first index from a 16-bit (unsigned) Morton code/Z-Code
        short value1 = (short)(morton & 0xffff);
        value1 &= 0x5555;
        value1 |= ( value1 >> 1 );
        value1 &= 0x3333;
        value1 |= ( value1 >> 2 );
        value1 &= 0x0f0f;
        value1 |= ( value1 >> 4 );
        value1 &= 0x00ff;
        return value1;
    }
    /**
     * Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the short
     * representing the y position.
     * This uses 16 bits of the 32-bit Morton code/Z-Code.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param morton A Morton code or Z-Code that interleaves two 8-bit numbers
     * @return A short that represents the y position extracted from the Morton code/Z-Code
     */
    public static short zDecodeY( final int morton )
    { // unpack the 8-bit (unsigned) second index from a 16-bit (unsigned) Morton code/Z-Code
        short value2 = (short)((morton & 0xffff) >>> 1 );
        value2 &= 0x5555;
        value2 |= ( value2 >> 1 );
        value2 &= 0x3333;
        value2 |= ( value2 >> 2 );
        value2 &= 0x0f0f;
        value2 |= ( value2 >> 4 );
        value2 &= 0x00ff;
        return value2;
    }

    /**
     * Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
     * representing the same x, y position.
     * This uses 16 bits of the Morton code and requires that the code is non-negative.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param morton an int containing two interleaved numbers, from 0 to 255 each
     * @return a Coord matching the x and y extracted from the Morton code
     */
    public static Coord mortonDecode( final int morton )
    { // unpack 2 8-bit (unsigned) indices from a 32-bit (signed...) Morton code
        int value1 = morton;
        int value2 = ( value1 >> 1 );
        value1 &= 0x5555;
        value2 &= 0x5555;
        value1 |= ( value1 >> 1 );
        value2 |= ( value2 >> 1 );
        value1 &= 0x3333;
        value2 &= 0x3333;
        value1 |= ( value1 >> 2 );
        value2 |= ( value2 >> 2 );
        value1 &= 0x0f0f;
        value2 &= 0x0f0f;
        value1 |= ( value1 >> 4 );
        value2 |= ( value2 >> 4 );
        value1 &= 0x00ff;
        value2 &= 0x00ff;
        return Coord.get(value1, value2);
    }
    /**
     * Takes a Morton code, with interleaved x and y bits and x in the least significant bit, and returns the Coord
     * representing the same x, y position. With this method, x and y can have up to 16 bits, but Coords returned by
     * this method will not be cached if they have a x or y component greater than 255.
     * This uses 32 bits of the Morton code and will treat the sign bit as the most significant bit of y, unsigned.
     * Source: http://and-what-happened.blogspot.com/2011/08/fast-2d-and-3d-hilbert-curves-and.html
     * @param morton an int containing two interleaved shorts.
     * @return a Coord matching the x and y extracted from the Morton code
     */
    public static Coord mortonDecode16( final int morton )
    { // unpack 2 16-bit indices from a 32-bit Morton code
        int value1 = morton;
        int value2 = ( value1 >>> 1 );
        value1 &= 0x55555555;
        value2 &= 0x55555555;
        value1 |= ( value1 >>> 1 );
        value2 |= ( value2 >>> 1 );
        value1 &= 0x33333333;
        value2 &= 0x33333333;
        value1 |= ( value1 >>> 2 );
        value2 |= ( value2 >>> 2 );
        value1 &= 0x0f0f0f0f;
        value2 &= 0x0f0f0f0f;
        value1 |= ( value1 >>> 4 );
        value2 |= ( value2 >>> 4 );
        value1 &= 0x00ff00ff;
        value2 &= 0x00ff00ff;
        value1 |= ( value1 >>> 8 );
        value2 |= ( value2 >>> 8 );
        value1 &= 0x0000ffff;
        value2 &= 0x0000ffff;
        return Coord.get(value1, value2);
    }
}
