package squidpony.squidmath;

import org.roaringbitmap.RoaringBitmap;

import java.util.ArrayList;
import java.util.Arrays;


/**
 * Provides static methods to encode Coords as single primitive ints in various ways, hence the namesake, but also
 * provides advanced methods to encode 2D arrays of various sorts produced by SquidLib in extremely memory-efficient
 * representations, and decode those representations to various types of 2D array on-demand.
 *<br>
 * NOTE: This class is atypically complex and low-level for SquidLib because it is attempting to attain some very
 * challenging performance gains. You should not consider it idiomatic SquidLib code or start modifying it unless
 * you have a good grasp of bitwise operations and the performance implications, particularly in regard to memory
 * consumption, that higher-level and more convenient Java programming techniques have.
 *<br>
 * The pack() methods in this class take a 2D array with a clear division between cells in an "on" state and cells in an
 * "off" state, and they produce a very tightly compressed short array that can be losslessly decompressed with the
 * unpack() methods to a boolean 2D array that stores equivalent on/off data to the input. The packMulti() method in
 * this class takes a double 2D array that has more than two states that may need to be encoded, such as an FOV map that
 * stores light level as a value between 0.0 and 1.0 instead of just on or off, and an additional double array that
 * defines what states should be distinguished in the result (for example, if the FOV can store values that differ by
 * 0.1 for a FOV radius of 10, you could pass the array of 10 levels: 0.1, 0.2, 0.3, ... 0.9, 1.0). The value returned
 * by packMulti() is a short[][], but with different array lengths for each sub-array (a jagged array); the length of
 * the short[][] is the same as the length of the levels array, and each sub-array corresponds to a different level of
 * FOV lighting or other gradation as defined in levels. This short[][] can be passed to the unpackMultiByte() method in
 * this class to produce a byte 2D array where the original levels correspond to progressively greater bytes, with 0
 * used for cells that were less than the smallest value in levels, 1 for values that were only greater than the
 * smallest value, and no others, in levels, then 2 for larger values, etc. until it places a byte with a value equal to
 * the length of levels in the cells that are the highest. There is also the unpackMultiDouble() method in this class
 * that takes the same short[][] unpackMultiByte() can take, but also takes a levels double array that should be the
 * same as the one used to compress short[][]. It will return a double 2D array with any cells that were smaller than
 * the smallest value in levels assigned 0.0, and any other cells will be assigned a double that corresponds to the
 * highest value in levels that does not exceed the original double at that location in the unpacked data. To make this
 * more clear, if you have 4 levels: [0.25, 0.5, 0.75, 1.0] and you packMulti() on an FOV with a large radius and
 * sample values 0.1, 0.45, 0.8, 1.0, you will get a packed short[][] with 4 sub-arrays to match the 4 levels. If you
 * then pass the short[][] and levels to unpackMultiDouble later, much of the same radius will be filled, but because
 * the sample value 0.1 was less than the smallest value in levels, its cell will be given 0.0. What was originally 0.45
 * will be given the next-lower levels value, 0.25; 0.8 will be given 0.75, and 1.0 will remain 1.0.
 *<br>
 * This compression is meant to produce a short[] or short[][] that uses as little memory as possible for the specific
 * case of compressing maps with these qualities:
 * <ul>
 *     <li>Maps are not especially large for a grid-based game; the maximum size is 256x256 cells.</li>
 *     <li>The vast majority of that 256x256 space is either unused or filled with cells no greater than 0.</li>
 *     <li>The cells that are greater than 0 are mostly near each other, though separate areas are possible.</li>
 * </ul>
 * These properties are all shared by typical roguelike FOV maps, and the specificity of these circumstances mean
 * extraordinarily dense compression can be achieved using the right combination of algorithms. In early testing,
 * using dungeon maps generated by {@link squidpony.squidgrid.mapping.DungeonGenerator} that should be typical of
 * roguelike maps and a diamond-shaped FOV with radius 8, compression of the short[] returned by pack() vs.
 * the original double[][] (which wastefully represents 2 states with 8 bytes) yields average memory usage ratios
 * between (with relatively optimal parameters) 0.0001237905030818498 in one of the best cases, and (with some very
 * poor parameters for the dungeon, but still using a realistic FOV map) 0.003135985198889917 in one of the worst.
 *<br>
 * This table shows the results for the average of 100 runs of pack() in a map with a "good size" and 100 runs in a map
 * with a "bad size." Both the compression ratio vs. a double[][] that stores only whether a cell is on or off and a
 * boolean[][] that stores the same information are provided.
 * <table BORDER CELLPADDING=3 CELLSPACING=1>
 *     <caption>Memory Performance of CoordPacker</caption>
 *     <tr>
 *         <th></th>
 *         <th>Bytes of RAM used, double 2D array</th>
 *         <th>Bytes of RAM used, boolean 2D array</th>
 *         <th>Average Bytes of RAM used, short 1D array (packed)</th>
 *         <th>Compression ratio, packed vs. doubles</th>
 *         <th>Compression ratio, packed vs. booleans</th>
 *     </tr>
 *     <tr>
 *         <td>240x240 dungeon map (good size)</td>
 *         <td>464656</td>
 *         <td>61456</td>
 *         <td>57.52</td>
 *         <td>0.0001237905030818498</td>
 *         <td>0.000935954178599323</td>
 *     </tr>
 *     <tr>
 *         <td>30x70 dungeon map (bad size)</td>
 *         <td>17296</td>
 *         <td>2656</td>
 *         <td>54.24</td>
 *         <td>0.003135985198889917</td>
 *         <td>0.020421686746987953</td>
 *     </tr>
 * </table>
 * In the best-case scenario of packing a 240x240 double array to a short array encoding two states, the result
 * uses less than 1/8000 the memory that the input uses. Writing to disk can store both input and output more
 * efficiently, but the method used here should ensure that even encoding the input FOV map as a flat sequence of
 * single bits and compressing the file should still be on par with the output of pack() due to optimization to
 * ensure nearby cells on a map are compressed together.
 *<br>
 * The technique used by this class is to walk along a Hilbert Curve, storing whether the walk is traveling through
 * "on" or "off" cells, which can be determined by a comparison to a number or a boolean, then encoding alternate shorts
 * into the short[] to be returned, with even-number indices (starting at 0) in the array corresponding to the number of
 * contiguous cells walked through in the "off" state, and odd-number indices corresponding to the number of
 * contiguous cells walked through in the "on" state. A user of this library does not need to understand the details
 * and properties of this algorithm unless they want to generate maps that will compress more optimally. In short:
 * <ul>
 * <li>Smaller maps tend to be processed faster by pack(), since the nature of a Hilbert Curve means a map that
 * fits in one half the width and one half the height of the curve only needs to walk one quarter of the Curve to
 * get all the needed information.</li>
 * <li>Smaller maps also compress less optimally ratio-wise than larger maps with the same area of "on" cells. The
 * compression ratio approaches its best when using very large maps, such as 240x240, and encoding just a few
 * cells on that map (such as for a small FOV radius or a cramped room). A map that is entirely "off" uses only 16
 * bytes of RAM (the minimum for any array on the JVM).</li>
 * <li>Unusually shaped maps can cause compression problems by forcing adjacent cells to sometimes require walking
 * more cells than needed to get to an adjacent cell. For example, a map greater than 64 cells tall, but less than
 * 33 cells wide, has properties that require walking through a large empty area to get to sometimes only a few
 * cells that are "on" before it walks back through empty space. Similarly, a map that is greater than 128 cells
 * tall but is otherwise narrow has the same property of requiring walking through empty space, but also requires
 * the entire Curve to be walked even if the map's width is only a tiny fraction of the Curve's 256 cells.</li>
 * </ul>
 * <b>In shorter-than-short</b>, you'll get particularly good results for compression speed and compressed size with
 * maps approximately these sizes: 240x240, 240x120, 120x120, 60x120, 60x60, 60x30, 30x30. The biggest maps have the
 * best relative gain on compressed memory usage, and the smallest maps have the best compression speed.
 *<br>
 * The details of the algorithm are not terribly complex once you understand the Hilbert Curve. The simplified
 * version of the Hilbert Curve that SquidLib employs is essentially a path through a square grid (it must have side
 * lengths that are powers of 2, and SquidLib always uses 256), starting in the corner cell (x=0,y=0), ending in the
 * corner cell (x=0,y=255), and traversing every other cell on the grid along its path without ever traveling in a
 * loop, crossing the path it walked, or moving in any direction but one cell up, down, left, or right. The shape
 * of the path this takes has the useful property of keeping most groups of cells walked through with similar x and
 * y at similar distances traveled from the start of the curve, and most groups of cells with very dissimilar x and
 * y at very different distances traveled. Since FOV and several other things you might want to encode with CoordPacker
 * tends to be clustered in small areas and occupy more complicated shapes than straight lines due to dungeon layout
 * blocking sections of FOV, the simplest paths of a wide zigzag from side-to-side, or an outward-going-in spiral, have
 * rather poor behavior when determining how much of an area they pass through contiguously. The contiguous area trait
 * is important because of the next step: Run-Length Encoding.
 *<br>
 * Run-Length Encoding is much simpler to explain than the Hilbert Curve, especially without visual aids. In the version
 * SquidLib uses, only on or off states need to be recorded, so the method used here is smaller and more efficient than
 * most methods that need to store repeated characters in strings (and letters, numbers, and punctuation clearly have
 * more than 2 states). The technique works like this:
 *<br>
 * Start in the "off" state, walk down the Hilbert Curve counting how many cells you walk through that are still "off,"
 * and when you encounter a cell that is "on," you write down how many cells were off, transition to the "on" state. Now
 * keep walking the Hilbert Curve, but counting how many cells you walk through that are still "on." When you reach
 * an "off" cell, write down how many were "on," then start walking and counting again, with your count starting at 0.
 * Repeat until you reach the end of the Hilbert Curve, but if you reach the end while counting "off" cells, you don't
 * need to write down that number (a shortcut allows many maps to stop sooner than the 65,536th element of the Curve).
 *<br>
 * There are some additional traits that relate to the edge of the map being treated as "off" even though no
 * calculations are done for cells out of map bounds, and some optimizations that ensure that maps that are smaller than
 * a half, a quarter, or an eighth of the 256x256 curve in both dimensions (and sometimes just one) only need to walk a
 * portion of the Hilbert Curve and simply skip the rest without walking it.
 *<br>
 * The Hilbert Curve has not been definitively proven to be the best possible path to ensure 1D distance and 2D location
 * are similar, but it has been extensively used for tasks that require similar locations for similar distances (in
 * particular, it has become useful in supercomputing clusters for allocating related work to physically nearby
 * machines), and since there hasn't been anything with better spatial properties discovered yet, this technique should
 * remain useful for some time.
 * <br>
 * Created by Tommy Ettinger on 10/1/2015.
 * @author Tommy Ettinger
 */
public class RegionPacker {     
    public static RoaringBitmap ALL_WALL = new RoaringBitmap(),
            ALL_ON = RoaringBitmap.add(new RoaringBitmap(), 0, 65536);

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that only stores two
     * relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
     * the {@link RegionPacker} class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
     * relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any double
     * greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
     * as possible for most roguelike FOV maps.
     *<br>
     * <b>To store more than two states</b>, you should use packMulti().
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method.
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static RoaringBitmap pack(double[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        RoaringBitmap packing = new RoaringBitmap();
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(CoordPacker.hilbertX[i] >= xSize || CoordPacker.hilbertY[i] >= ySize) {
                continue;
            }
            ml++;
            if(map[CoordPacker.hilbertX[i]][CoordPacker.hilbertY[i]] > 0.0)
                packing.add(i);
        }
        if(packing.getCardinality() == 0)
            return ALL_WALL;
        packing.trim();
        return packing;
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidai.DijkstraMap}) that only stores two
     * relevant states (one of which should be equal to or less than threshold, the other greater than threshold),
     * returning a short[] as described in the {@link RegionPacker} class documentation. This short[] can be passed to
     * CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][] (with true meaning
     * threshold or less and false being any double greater than threshold). As stated in the class documentation, the
     * compressed result is intended to use as little memory as possible for most roguelike FOV maps, but here is also
     * useful for compressing physical maps and gradient maps from DijkstraMap.
     * <br>
     * <b>To store more than two states</b>, you should use packMulti().
     *
     * @param map a double[][] that probably relates in some way to DijkstraMap.
     * @param threshold any double greater than this will be off, any equal or less will be on
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static RoaringBitmap pack(double[][] map, double threshold)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        RoaringBitmap packing = new RoaringBitmap();
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(CoordPacker.hilbertX[i] >= xSize || CoordPacker.hilbertY[i] >= ySize) {
                continue;
            }
            ml++;
            if(map[CoordPacker.hilbertX[i]][CoordPacker.hilbertY[i]] <= threshold)
                packing.add(i);
        }
        if(packing.getCardinality() == 0)
            return ALL_WALL;
        packing.trim();
        return packing;
    }

    /**
     * Compresses a byte[][] (typically one generated by an FOV-like method) that only stores two
     * relevant states (one of which should be 0 or less, the other greater than 0), returning a short[] as described in
     * the {@link RegionPacker} class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
     * relevant states and their positions as a boolean[][] (with false meaning 0 or less and true being any byte
     * greater than 0). As stated in the class documentation, the compressed result is intended to use as little memory
     * as possible for most roguelike FOV maps.
     *<br>
     * <b>To store more than two states</b>, you should use packMulti().
     *
     * @param map a byte[][] that probably was returned by an FOV-like method.
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static RoaringBitmap pack(byte[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        RoaringBitmap packing = new RoaringBitmap();
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(CoordPacker.hilbertX[i] >= xSize || CoordPacker.hilbertY[i] >= ySize) {
                continue;
            }
            ml++;
            if(map[CoordPacker.hilbertX[i]][CoordPacker.hilbertY[i]] > 0)
                packing.add(i);
        }
        if(packing.getCardinality() == 0)
            return ALL_WALL;
        packing.trim();
        return packing;
    }
    /**
     * Compresses a boolean[][], returning a short[] as described in the {@link RegionPacker} class documentation. This
     * short[] can be passed to CoordPacker.unpack() to restore the relevant states and their positions as a boolean[][]
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *
     * @param map a boolean[][] that should ideally be mostly false.
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static RoaringBitmap pack(boolean[][] map)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        RoaringBitmap packing = new RoaringBitmap();
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(CoordPacker.hilbertX[i] >= xSize || CoordPacker.hilbertY[i] >= ySize) {
                continue;
            }
            ml++;
            if(map[CoordPacker.hilbertX[i]][CoordPacker.hilbertY[i]])
                packing.add(i);
        }
        if(packing.getCardinality() == 0)
            return ALL_WALL;
        packing.trim();
        return packing;
    }

    /**
     * Compresses a char[][] (typically one generated by a map generating method) sp only the cells that equal the yes
     * parameter will be encoded as "on", returning a short[] as described in
     * the {@link RegionPacker} class documentation. This short[] can be passed to CoordPacker.unpack() to restore the
     * positions of chars that equal the parameter yes as a boolean[][] (with false meaning not equal and true equal to
     * yes). As stated in the class documentation, the compressed result is intended to use as little memory
     * as possible for most roguelike FOV maps, but this will typically not be used for FOV (more typical uses are for
     * walls, floors, and so on). This can still be useful for certain kinds of processing that can be done more
     * efficiently on packed data than on 2D arrays, like unions, intersections, and random elements or subsets.
     *
     * @param map a char[][] that may contain some area of cells that you want stored as packed data
     * @param yes the char to encode as "on" in the result; all others are encoded as "off"
     * @return a packed short[] that should, in most circumstances, be passed to unpack() when it needs to be used.
     */
    public static RoaringBitmap pack(char[][] map, char yes)
    {
        if(map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.pack() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if(xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        RoaringBitmap packing = new RoaringBitmap();
        int skip = 0, limit = 0x10000, mapLimit = xSize * ySize;
        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }

        for(int i = 0, ml = 0; i < limit && ml < mapLimit; i++, skip++)
        {
            if(CoordPacker.hilbertX[i] >= xSize || CoordPacker.hilbertY[i] >= ySize) {
                continue;
            }
            ml++;
            if(map[CoordPacker.hilbertX[i]][CoordPacker.hilbertY[i]] == yes)
                packing.add(i);
        }
        if(packing.getCardinality() == 0)
            return ALL_WALL;
        packing.trim();
        return packing;
    }

    /**
     * Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
     * array that can be passed to packMulti() to ensure that you have the requested number of separate levels in the
     * multi-packed result. For example, if you pass 6 to this method, it will return a length-6 double array, and if
     * you pass that as the levels parameter to packMulti(), then that method will return a length-6 array of short
     * arrays that each encode a region that met a different minimum value in the originally packed double[][].
     * The behavior of this method causes any doubles that are closer to 1.0 / totalLevels than they are to 0.0 to be
     * packed as "on" in at least one of packMulti()'s resultant sub-arrays. This allows Radius.CIRCLE or similar FOV
     * that produces cells with values that aren't evenly distributed between 0.0 and 1.0 to be used without causing an
     * explosion in the number of required levels.
     * <br>
     * <b>This method should not be used to generate levels for unpacking; it is only intended for packing.</b> Use the
     * similar method generateLightLevels() to generate a levels array that is suitable for unpacking FOV.
     * @param totalLevels the number of separate levels to group doubles into
     * @return a double[] suitable as a levels parameter for packMulti()
     */
    public static double[] generatePackingLevels(int totalLevels)
    {
        if (totalLevels > 63 || totalLevels <= 0)
            throw new UnsupportedOperationException(
                    "Bad totalLevels; should be 0 < totalLevels < 64 but was given " +
                            totalLevels);

        double[] levels = new double[totalLevels];
        for (int i = 0; i < totalLevels; i++) {
            levels[i] = 1.0 * i / totalLevels + 0.5 / totalLevels;
        }
        return levels;
    }

    /**
     * Given a number of total levels to consider separate in a double[][] such as an FOV result, this produces a levels
     * array that can be passed to unpackMultiDouble() to ensure that the minimum double returned for an "on" cell is
     * 1.0 / totalLevels, and every progressively tighter level in the short[][] being unpacked will be close to a
     * multiple of that minimum double value. This only applies to "on" cells; any cells that did not meet a minimum
     * value when packed will still be 0.0. For example, if you pass 6 to this method, it will return a length-6 double
     * array, and if you pass that as the levels parameter to unpackMultiDouble(), then that method will return a
     * double[][] with no more than totalLevels + 1 used values, ranging from 0.0 to 1.0 with evenly spaced values, all
     * multiples of 1.0 / totalLevels, in between.
     * <br>
     * <b>This method should not be used to generate levels for packing; it is only intended for unpacking.</b> Use the
     * similar method generatePackingLevels() to generate a levels array that is suitable for packing double[][] values.
     * @param totalLevels the number of separate levels to assign doubles; this MUST match the size of the levels
     *                    parameter used to pack a double[][] with packMulti() if this is used to unpack that data
     * @return a double[] suitable as a levels parameter for unpackMultiDouble()
     */
    public static double[] generateLightLevels(int totalLevels)
    {
        if (totalLevels > 63 || totalLevels <= 0)
            throw new UnsupportedOperationException(
                    "Bad totalLevels; should be 0 < totalLevels < 64 but was given " +
                            totalLevels);

        double[] levels = new double[totalLevels];
        for (int i = 0; i < totalLevels; i++) {
            levels[i] = (i + 1.0) / totalLevels;
        }
        return levels;
    }

    /**
     * Compresses a double[][] (typically one generated by {@link squidpony.squidgrid.FOV}) that stores any number of
     * states and a double[] storing up to 63 states, ordered from lowest to highest, returning a short[][] as described
     * in the {@link RegionPacker} class documentation. This short[][] can be passed to CoordPacker.unpackMultiDouble()
     * to restore the state at a position to the nearest state in levels, rounded down, and return a double[][] that
     * should preserve the states as closely as intended for most purposes. <b>For compressing FOV, you should generate
     * levels with CoordPacker.generatePackingLevels()</b> instead of manually creating the array, because some
     * imprecision is inherent in floating point math and comparisons are often incorrect between FOV with multiple
     * levels and exact levels generated as simply as possible. generatePackingLevels() adds a small correction to the
     * levels to compensate for floating-point math issues, which shouldn't affect the correctness of the results for
     * FOV radii under 100.
     *<br>
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *<br>
     * <b>To store only two states</b>, you should use pack(), unless the double[][] divides data into on and off based
     * on a relationship to some number other than 0.0. To (probably poorly) pack all the walls (and any cells with
     * values higher than DijkstraMap.WALL) in a DijkstraMap's 2D array of doubles called dijkstraArray, you could call
     * <code>packMulti(dijkstraArray, new double[]{DijkstraMap.WALL});</code>
     * Then, you would use only the one sub-element of the returned short[][].
     *
     * @param map a double[][] that probably was returned by FOV. If you obtained a double[][] from DijkstraMap, it
     *            will not meaningfully compress with this method unless you have very specific needs.
     * @param levels a double[] starting with the lowest value that should be counted as "on" (the outermost cells of
     *               an FOV map that has multiple grades of brightness would be counted by this) and ascending until the
     *               last value; the last value should be highest (commonly 1.0 for FOV), and will be used for any cells
     *               higher than all the other levels values. An example is an array of: 0.25, 0.5, 0.75, 1.0
     * @return a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
     *               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
     *               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
     *               lengths by the end of the short[][].
     */
    public static RoaringBitmap[] packMulti(double[][] map, double[] levels) {
        if (levels == null || levels.length == 0)
            throw new UnsupportedOperationException("Must be given at least one level");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to efficiently pack; should be less than 64 but was given " +
                            levels.length);
        if (map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packMulti() must be given a non-empty array");
        int xSize = map.length, ySize = map[0].length;
        if (xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        int limit = 0x10000, llen = levels.length, mapLimit = xSize * ySize;
        RoaringBitmap[] packing = new RoaringBitmap[llen];

        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short x, y;
        for(int l = 0; l < llen; l++) {
            packing[l] = new RoaringBitmap();
            for (int i = 0, ml = 0; i < limit && ml < mapLimit; i++) {
                x = CoordPacker.hilbertX[i];
                y = CoordPacker.hilbertY[i];
                if (x >= xSize || y >= ySize) {
                    continue;
                }
                ml++;

                if(map[x][y] > levels[l])
                    packing[l].add(i);
            }
            if(packing[l].getCardinality() == 0)
                packing[l] = ALL_WALL;
        }
        return packing;
    }

    /**
     * Compresses a byte[][] (typically one generated by {@link squidpony.squidgrid.FOVCache}) that stores any number
     * of states and an int no more than 63, returning a short[][] as described in the {@link RegionPacker} class
     * documentation. This short[][] can be passed to CoordPacker.unpackMultiByte() to restore the state at a position
     * to the nearest state possible, capped at levelCount, and return a byte[][] that should preserve the states as
     * closely as intended for most purposes.
     *<br>
     * As stated in the class documentation, the compressed result is intended to use as little memory as possible for
     * most roguelike FOV maps.
     *<br>
     * <b>To store only two states</b>, you should use pack().
     *
     * @param map a byte[][] that probably was returned by a specialized FOV.
     * @param levelCount an int expressing how many levels should be present in the output; values greater than
     *                   levelCount in map will be treated as the highest level.
     * @return a packed short[][] that should, in most circumstances, be passed to unpackMultiDouble() or
     *               unpackMultiByte() when it needs to be used. The 2D array will be jagged with an outer length equal
     *               to the length of levels and sub-arrays that go from having longer lengths early on to very compact
     *               lengths by the end of the short[][].
     */
    public static RoaringBitmap[] packMulti(byte[][] map, int levelCount) {
        if (map == null || map.length == 0)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.packMulti() must be given a non-empty array");
        if (levelCount > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to efficiently pack; should be less than 64 but was given " +
                            levelCount);
        int xSize = map.length, ySize = map[0].length;
        if (xSize > 256 || ySize > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        int limit = 0x10000, mapLimit = xSize * ySize;
        RoaringBitmap[] packing = new RoaringBitmap[levelCount];

        if(ySize <= 128) {
            limit >>= 1;
            if (xSize <= 128) {
                limit >>= 1;
                if (xSize <= 64) {
                    limit >>= 1;
                    if (ySize <= 64) {
                        limit >>= 1;
                        if (ySize <= 32) {
                            limit >>= 1;
                            if (xSize <= 32) {
                                limit >>= 1;
                            }
                        }
                    }
                }
            }
        }
        short x, y;
        for(int l = 0; l < levelCount; l++) {
            packing[l] = new RoaringBitmap();
            for (int i = 0, ml = 0; i < limit && ml < mapLimit; i++) {
                x = CoordPacker.hilbertX[i];
                y = CoordPacker.hilbertY[i];
                if (x >= xSize || y >= ySize) {
                    continue;
                }
                ml++;

                if(map[x][y] > l)
                    packing[l].add(i);
            }
            if(packing[l].getCardinality() == 0)
                packing[l] = ALL_WALL;
        }
        return packing;
    }

    /**
     * Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
     * the {@link RegionPacker} class documentation. This returns a boolean[][] that stores the same values that were
     * packed if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
     * boolean[][] this returns will have true for all values greater than 0 and false for all others. If this is one
     * of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
     * array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
     * true, while all others will be false. Width and height do not technically need to match the dimensions of the
     * original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[] encoded by calling one of this class' packing methods on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a boolean[][] storing which cells encoded by packed are on (true) or off (false).
     */
    public static boolean[][] unpack(RoaringBitmap packed, int width, int height)
    {
        if(packed == null)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.unpack() must be given a non-null array");
        boolean[][] unpacked = new boolean[width][height];
        if(packed.getCardinality() == 0)
            return unpacked;
        int idx = 0;
        short x =0, y = 0;
        int[] positions = packed.toArray();

        for(int p = 0; p < positions.length; p++) {
            idx = positions[p];
            x = CoordPacker.hilbertX[idx];
            y = CoordPacker.hilbertY[idx];
            if(x >= width || y >= height)
                continue;
            unpacked[x][y] = true;
        }
        return unpacked;
    }

    /**
     * Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
     * the {@link RegionPacker} class documentation. This returns a double[][] that stores 1.0 for true and 0.0 for
     * false if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
     * double[][] this returns will have 1.0 for all values greater than 0 and 0.0 for all others. If this is one
     * of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
     * array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
     * 1.0, while all others will be 0.0. Width and height do not technically need to match the dimensions of the
     * original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[] encoded by calling one of this class' packing methods on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a double[][] storing which cells encoded by packed are on (1.0) or off (0.0).
     */
    public static double[][] unpackDouble(RoaringBitmap packed, int width, int height)
    {
        if(packed == null)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.unpack() must be given a non-null array");
        double[][] unpacked = new double[width][height];
        if(packed.getCardinality() == 0)
            return unpacked;
        int idx = 0;
        short x =0, y = 0;
        int[] positions = packed.toArray();

        for(int p = 0; p < positions.length; p++) {
            idx = positions[p];
            x = CoordPacker.hilbertX[idx];
            y = CoordPacker.hilbertY[idx];
            if(x >= width || y >= height)
                continue;
            unpacked[x][y] = 1.0;
        }
        return unpacked;
    }


    /**
     * Decompresses a short[] returned by pack() or a sub-array of a short[][] returned by packMulti(), as described in
     * the {@link RegionPacker} class documentation. This returns a double[][] that stores 1.0 for true and 0.0 for
     * false if the overload of pack() taking a boolean[][] was used. If a double[][] was compressed with pack(), the
     * double[][] this returns will have 1.0 for all values greater than 0 and 0.0 for all others. If this is one
     * of the sub-arrays compressed by packMulti(), the index of the sub-array will correspond to an index in the levels
     * array passed to packMulti(), and any cells that were at least equal to the corresponding value in levels will be
     * 1.0, while all others will be 0.0. Width and height do not technically need to match the dimensions of the
     * original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[] encoded by calling one of this class' packing methods on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a double[][] storing which cells encoded by packed are on (1.0) or off (0.0).
     */
    public static double[][] unpackDoubleConical(RoaringBitmap packed, int width, int height,  int centerX, int centerY,
                                                 double angle, double span)
    {
        if(packed == null)
            throw new ArrayIndexOutOfBoundsException("CoordPacker.unpack() must be given a non-null array");
        double[][] unpacked = new double[width][height];
        if(packed.getCardinality() == 0)
            return unpacked;
        int idx = 0;
        short x =0, y = 0;
        double angle2 = Math.toRadians((angle > 360.0 || angle < 0.0) ? Math.IEEEremainder(angle + 720.0, 360.0) : angle);
        double span2 = Math.toRadians(span);
        int[] positions = packed.toArray();

        for(int p = 0; p < positions.length; p++) {
            idx = positions[p];
            x = CoordPacker.hilbertX[idx];
            y = CoordPacker.hilbertY[idx];
            if(x >= width || y >= height)
                continue;
            double newAngle = Math.atan2(y - centerY, x - centerX) + Math.PI * 2;
            if(Math.abs(Math.IEEEremainder(angle2 - newAngle, Math.PI * 2)) <= span2 / 2.0)
                unpacked[x][y] = 1.0;
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
     * using the given levels double[] as the values to assign, as described in the {@link RegionPacker} class
     * documentation. The length of levels and the length of the outer array of packed must be equal. However, the
     * levels array passed to this method should not be identical to the levels array passed to packMulti(); for FOV
     * compression, you should get an array for levels using generatePackingLevels(), but for decompression, you should
     * create levels using generateLightLevels(), which should more appropriately fit the desired output. Reusing the
     * levels array used to pack the FOV will usually produce values at the edge of FOV that are less than 0.01 but
     * greater than 0, and will have a maximum value somewhat less than 1.0; neither are usually desirable, but using a
     * different array made with generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at
     * the highest. Width and height do not technically need to match the dimensions of the original 2D array, but under
     * most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @param levels a double[] that must have the same length as packed, and will be used to assign cells in the
     *               returned double[][] based on what levels parameter was used to compress packed
     * @return a double[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to the nth value in the levels parameter passed to this method.
     */
    public static double[][] unpackMultiDouble(RoaringBitmap[] packed, int width, int height, double[] levels)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiDouble() must be given a non-empty array");
        if (levels == null || levels.length != packed.length)
            throw new UnsupportedOperationException("The lengths of packed and levels must be equal");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to be packed by CoordPacker; should be less than 64 but was given " +
                            levels.length);
        double[][] unpacked = new double[width][height];
        short x= 0, y = 0;
        for(int l = 0; l < packed.length; l++) {
            int[] positions = packed[l].toArray();
            int idx = 0;
            for (int p = 0; p < positions.length; p++) {
                idx = positions[p];
                x = CoordPacker.hilbertX[idx];
                y = CoordPacker.hilbertY[idx];
                if(x >= width || y >= height)
                    continue;
                unpacked[x][y] = levels[l];
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
     * using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
     * described in the {@link RegionPacker} class documentation. The length of levels and the length of the outer array
     * of packed do not have to be equal. However, the levels array passed to this method should not be identical to the
     * levels array passed to packMulti(); for FOV compression, you should get an array for levels using
     * generatePackingLevels(), but for decompression, you should create levels using generateLightLevels(), which
     * should more appropriately fit the desired output. Reusing the levels array used to pack the FOV will usually
     * produce values at the edge of FOV that are less than 0.01 but greater than 0, and will have a maximum value
     * somewhat less than 1.0; neither are usually desirable, but using a different array made with
     * generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at the highest. Width and
     * height do not technically need to match the dimensions of the original 2D array, but under most circumstances
     * where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @param levels a double[] that must have the same length as packed, and will be used to assign cells in the
     *               returned double[][] based on what levels parameter was used to compress packed
     * @param limit the number of elements to consider from levels and packed, starting from the innermost.
     * @return a double[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to the nth value in the levels parameter passed to this method.
     */
    public static double[][] unpackMultiDoublePartial(RoaringBitmap[] packed, int width, int height, double[] levels,
                                                      int limit)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiDouble() must be given a non-empty array");
        if (levels == null || levels.length != packed.length)
            throw new UnsupportedOperationException("The lengths of packed and levels must be equal");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to be packed by CoordPacker; should be less than 64 but was given " +
                            levels.length);
        if(limit > levels.length)
            limit = levels.length;
        double[][] unpacked = new double[width][height];
        short x= 0, y = 0;
        for(int l = packed.length - limit; l < packed.length; l++) {
            int[] positions = packed[l].toArray();
            int idx = 0;
            for (int p = 0; p < positions.length; p++) {
                idx = positions[p];
                x = CoordPacker.hilbertX[idx];
                y = CoordPacker.hilbertY[idx];
                if(x >= width || y >= height)
                    continue;
                unpacked[x][y] = levels[l];
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces an approximation of the double[][] it compressed
     * using the given levels double[] as the values to assign, but only using the innermost indices up to limit, as
     * described in the {@link RegionPacker} class documentation. The length of levels and the length of the outer array
     * of packed do not have to be equal. However, the levels array passed to this method should not be identical to the
     * levels array passed to packMulti(); for FOV compression, you should get an array for levels using
     * generatePackingLevels(), but for decompression, you should create levels using generateLightLevels(), which
     * should more appropriately fit the desired output. Reusing the levels array used to pack the FOV will usually
     * produce values at the edge of FOV that are less than 0.01 but greater than 0, and will have a maximum value
     * somewhat less than 1.0; neither are usually desirable, but using a different array made with
     * generateLightLevels() will produce doubles ranging from 1.0 / levels.length to 1.0 at the highest. This method
     * takes an angle and span as well as a centerX and centerY; the only values that will be greater than 0.0 in the
     * result will be within the round-based conical section that could be produced by traveling from (centerX,centerY)
     * along angle in a limitless line and expanding the cone to be span degrees broad (circularly), centered on angle.
     * Width and height do not technically need to match the dimensions of the original 2D array, but under most
     * circumstances where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @param levels a double[] that must have the same length as packed, and will be used to assign cells in the
     *               returned double[][] based on what levels parameter was used to compress packed
     * @param limit the number of elements to consider from levels and packed, starting from the innermost.
     * @param centerX the x position of the corner or origin of the conical FOV
     * @param centerY the y position of the corner or origin of the conical FOV
     * @param angle the center of the conical area to limit this to, in degrees
     * @param span the total span of the conical area to limit this to, in degrees
     * @return a double[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to the nth value in the levels parameter passed to this method.
     */
    public static double[][] unpackMultiDoublePartialConical(RoaringBitmap[] packed, int width, int height, double[] levels,
                                                      int limit, int centerX, int centerY, double angle, double span)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiDouble() must be given a non-empty array");
        if (levels == null || levels.length != packed.length)
            throw new UnsupportedOperationException("The lengths of packed and levels must be equal");
        if (levels.length > 63)
            throw new UnsupportedOperationException(
                    "Too many levels to be packed by CoordPacker; should be less than 64 but was given " +
                            levels.length);
        if(limit > levels.length)
            limit = levels.length;

        double angle2 = Math.toRadians((angle > 360.0 || angle < 0.0) ? Math.IEEEremainder(angle + 720.0, 360.0) : angle);
        double span2 = Math.toRadians(span);
        double[][] unpacked = new double[width][height];
        short x= 0, y = 0;
        for(int l = packed.length - limit; l < packed.length; l++) {
            int[] positions = packed[l].toArray();
            int idx = 0;
            for (int p = 0; p < positions.length; p++) {
                idx = positions[p];
                x = CoordPacker.hilbertX[idx];
                y = CoordPacker.hilbertY[idx];
                if(x >= width || y >= height)
                    continue;
                double newAngle = Math.atan2(y - centerY, x - centerX) + Math.PI * 2;
                if(Math.abs(Math.IEEEremainder(angle2 - newAngle, Math.PI * 2)) <= span2 / 2.0)
                    unpacked[x][y] = levels[l];
            }
        }
        return unpacked;
    }

    /**
     * Decompresses a short[][] returned by packMulti() and produces a simple 2D array where the values are bytes
     * corresponding to 1 + the highest index into levels (that is, the original levels parameter passed to packMulti)
     * matched by a cell, or 0 if the cell didn't match any levels during compression, as described in the
     * {@link RegionPacker} class documentation. Width and height do not technically need to match the dimensions of
     * the original 2D array, but under most circumstances where they don't match, the data produced will be junk.
     * @param packed a short[][] encoded by calling this class' packMulti() method on a 2D array.
     * @param width the width of the 2D array that will be returned; should match the unpacked array's width.
     * @param height the height of the 2D array that will be returned; should match the unpacked array's height.
     * @return a byte[][] where the values that corresponded to the nth value in the levels parameter used to
     * compress packed will now correspond to bytes with the value n+1, or 0 if they were "off" in the original array.
     */
    public static byte[][] unpackMultiByte(RoaringBitmap[] packed, int width, int height)
    {
        if(packed == null || packed.length == 0)
            throw new ArrayIndexOutOfBoundsException(
                    "CoordPacker.unpackMultiByte() must be given a non-empty array");
        byte[][] unpacked = new byte[width][height];
        byte lPlus = 1;
        short x=0, y=0;
        for(int l = 0; l < packed.length; l++, lPlus++) {
            int[] positions = packed[l].toArray();
            int idx = 0;
            for (int p = 0; p < positions.length; p++) {
                idx = positions[p];
                x = CoordPacker.hilbertX[idx];
                y = CoordPacker.hilbertY[idx];
                if(x >= width || y >= height)
                    continue;
                unpacked[x][y] = lPlus;
            }
        }
        return unpacked;
    }

    /**
     * Quickly determines if an x,y position is true or false in the given packed array, without unpacking it.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @param x between 0 and 255, inclusive
     * @param y between 0 and 255, inclusive
     * @return true if the packed data stores true at the given x,y location, or false in any other case.
     */
    public static boolean queryPacked(RoaringBitmap packed, int x, int y)
    {
        int hilbertDistance = CoordPacker.posToHilbert(x, y);
        return packed.contains(hilbertDistance);
    }
    /**
     * Quickly determines if a Hilbert Curve index corresponds to true or false in the given packed array, without
     * unpacking it.
     * <br>
     * Typically this method will not be needed by library-consuming code unless that code deals with Hilbert Curves in
     * a frequent and deeply involved manner. It does have the potential to avoid converting to and from x,y coordinates
     * and Hilbert Curve indices unnecessarily, which could matter for high-performance code.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @param hilbert a Hilbert Curve index, such as one taken directly from a packed short[] without extra processing
     * @return true if the packed data stores true at the given Hilbert Curve index, or false in any other case.
     */
    public static boolean queryPackedHilbert(RoaringBitmap packed, int hilbert)
    {
        return packed.contains(hilbert);

    }

    /**
     * Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as a Coord[].
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @return a Coord[], ordered by distance along the Hilbert Curve, corresponding to all "on" cells in packed.
     */
    public static Coord[] allPacked(RoaringBitmap packed)
    {
        int[] positions = packed.toArray();
        Coord[] cs = new Coord[positions.length];
        for(int i = 0; i < positions.length; i++) {
            cs[i] = Coord.get(CoordPacker.hilbertX[positions[i]], CoordPacker.hilbertY[positions[i]]);
        }
        return cs;
    }
    /**
     * Gets all positions that are "on" in the given packed array, without unpacking it, and returns them as an array of
     * Hilbert Curve indices.
     * <br>
     * Typically this method will not be needed by library-consuming code unless that code deals with Hilbert Curves in
     * a frequent and deeply involved manner. It does have the potential to avoid converting to and from x,y coordinates
     * and Hilbert Curve indices unnecessarily, which could matter for high-performance code.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check due to very tight performance constraints).
     * @return a Hilbert Curve index array, in ascending distance order, corresponding to all "on" cells in packed.
     */
    public static int[] allPackedHilbert(RoaringBitmap packed)
    {
        return packed.toArray();
    }

    private static int clamp(int n, int min, int max)
    {
        return Math.min(Math.max(min, n), max - 1);
    }

    /**
     * Move all "on" positions in packed by the number of cells given in xMove and yMove, unless the move
     * would take them further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case that
     * cell is stopped at the edge (moving any shape by an xMove greater than width or yMove greater than
     * height will move all "on" cells to that edge, in a 1-cell thick line). Returns a new packed short[]
     * and does not modify packed.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()
     * @param xMove distance to move the x-coordinate; can be positive or negative
     * @param yMove distance to move the y-coordinate; can be positive or negative
     * @param width the maximum width; if a cell would move to x at least equal to width, it stops at width - 1
     * @param height the maximum height; if a cell would move to y at least equal to height, it stops at height - 1
     * @return a packed array that encodes "on" for cells that were moved from cells that were "on" in packed
     */
    public static RoaringBitmap translate(RoaringBitmap packed, int xMove, int yMove, int width, int height)
    {
        if(packed == null || packed.getCardinality() == 0)
        {
            return ALL_WALL;
        }
        RoaringBitmap packing = new RoaringBitmap();
        int idx = 0, x, y;
        int[] positions = packed.toArray();
        for(int p = 0; p < positions.length; p++) {
            idx = positions[p];
            x = clamp(CoordPacker.hilbertX[idx] + xMove, 0, width);
            y = clamp(CoordPacker.hilbertY[idx] + yMove, 0, height);
            packing.add(CoordPacker.hilbertDistances[x + (y << 8)] & 0xffff);
        }
        return packing;
    }


    /**
     * Expand each "on" position in packed to cover a a square with side length equal to 1 + expansion * 2,
     * centered on the original "on" position, unless the expansion would take a cell further than 0,
     * width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
     * Returns a new packed short[] and does not modify packed.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()
     * @param expansion the positive (square) radius, in cells, to expand each cell out by
     * @param width the maximum width; if a cell would move to x at least equal to width, it stops at width - 1
     * @param height the maximum height; if a cell would move to y at least equal to height, it stops at height - 1
     * @return a packed array that encodes "on" for cells that were moved from cells that were "on" in packed
     */
    public static RoaringBitmap expand(RoaringBitmap packed, int expansion, int width, int height)
    {
        if(packed == null || packed.getCardinality() == 0)
        {
            return ALL_WALL;
        }
        ShortSet ss = new ShortSet(256);
        RoaringBitmap packing = new RoaringBitmap();
        int[] positions = packed.toArray();
        int idx = 0, x, y;
        short dist;
        for(int p = 0; p < positions.length; p++) {
            idx = positions[p];
            x = CoordPacker.hilbertX[idx];
            y = CoordPacker.hilbertY[idx];
            for (int j = Math.max(0, x - expansion); j <= Math.min(width - 1, x + expansion); j++) {
                for (int k = Math.max(0, y - expansion); k <= Math.min(height - 1, y + expansion); k++) {
                    dist = CoordPacker.hilbertDistances[j + (k << 8)];
                    if (ss.add(dist))
                        packing.add(dist & 0xffff);
                }
            }
        }
        return packing;
    }


    /**
     * Finds the area around the cells encoded in packed, without including those cells. For each "on"
     * position in packed, expand it to cover a a square with side length equal to 1 + expansion * 2,
     * centered on the original "on" position, unless the expansion would take a cell further than 0,
     * width - 1 (for xMove) or height - 1 (for yMove), in which case that cell is stopped at the edge.
     * If a cell is "on" in packed, it will always be "off" in the result.
     * Returns a new packed short[] and does not modify packed.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()
     * @param expansion the positive (square-shaped) radius, in cells, to expand each cell out by
     * @param width the maximum width; if a cell would move to x at least equal to width, it stops at width - 1
     * @param height the maximum height; if a cell would move to y at least equal to height, it stops at height - 1
     * @return a packed array that encodes "on" for cells that were pushed from the edge of packed's "on" cells
     */
    public static RoaringBitmap fringe(RoaringBitmap packed, int expansion, int width, int height)
    {
        if(packed == null || packed.getCardinality() == 0)
        {
            return ALL_WALL;
        }
        RoaringBitmap exp = expand(packed, expansion, width, height);
        exp.andNot(packed);
        return exp;
    }

    /**
     * Finds the concentric areas around the cells encoded in packed, without including those cells. For each "on"
     * position in packed, expand it to cover a a square with side length equal to 1 + n * 2, where n starts at 1 and
     * goes up to include the expansions parameter, with each expansion centered on the original "on" position, unless
     * the expansion would take a cell further than 0, width - 1 (for xMove) or height - 1 (for yMove), in which case
     * that cell is stopped at the edge. If a cell is "on" in packed, it will always be "off" in the results.
     * Returns a new packed short[][] where the outer array has length equal to expansions and the inner arrays are
     * packed data encoding a one-cell-wide concentric fringe region. Does not modify packed.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti()
     * @param expansions the positive (square-shaped) radius, in cells, to expand each cell out by, also the length
     *                   of the outer array returned by this method
     * @param width the maximum width; if a cell would move to x at least equal to width, it stops at width - 1
     * @param height the maximum height; if a cell would move to y at least equal to height, it stops at height - 1
     * @return an array of packed arrays that encode "on" for cells that were pushed from the edge of packed's "on"
     *          cells; the outer array will have length equal to expansions, and inner arrays will normal packed data
     */
    public static RoaringBitmap[] fringes(RoaringBitmap packed, int expansions, int width, int height) {
        RoaringBitmap[] finished = new RoaringBitmap[expansions];
        if (packed == null || packed.getCardinality() == 0) {
            Arrays.fill(finished, ALL_WALL);
            return finished;
        }
        RoaringBitmap exp = packed.clone();
        for (int expansion = 1; expansion <= expansions; expansion++) {
            RoaringBitmap exp2 = expand(exp, expansion, width, height);
            finished[expansion-1] = RoaringBitmap.andNot(exp2, exp);
            exp = exp2;
        }
        return finished;
    }

    /**
     * Given a width and height, returns a packed array that encodes "on" for the rectangle from (0,0) to
     * (width - 1, height - 1). Primarily useful with intersectPacked() to ensure things like negatePacked() that can
     * encode "on" cells in any position are instead limited to the bounds of the map.
     * @param width the width of the map
     * @param height the height of the map
     * @return a packed short[] encoding "on" for all cells with x less than width and y less than height.
     */
    public static RoaringBitmap rectangle(int width, int height)
    {
        if(width > 256 || height > 256)
            throw new UnsupportedOperationException("Map size is too large to efficiently pack, aborting");
        boolean[][] rect = new boolean[width][height];
        for (int i = 0; i < width; i++) {
            Arrays.fill(rect[i], true);
        }
        return pack(rect);
    }

    /**
     * Counts the number of "on" cells encoded in a packed array without unpacking it.
     * @param packed a packed short array, as produced by pack()
     * @return the number of "on" cells.
     */
    public static int count(RoaringBitmap packed)
    {
        return packed.getCardinality();
    }

    /**
     * Counts the number of cells encoding a boolean equal to wanted in a packed array without unpacking it.
     * @param packed a packed short array, as produced by pack()
     * @param wanted the boolean you want to count, true for "on" and false for "off"
     * @return the number of cells that encode a value equal to wanted.
     */
    public static int count(RoaringBitmap packed, boolean wanted)
    {
        if(wanted)
            return packed.getCardinality();
        else
            return 65536 - packed.getCardinality();
    }
    /**
     * Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
     * that was "on" in either left or in right, and only encodes "off" for cells that were off in both. This method
     * does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
     * when merging two pieces of packed data.
     * @param left A packed array such as one produced by pack()
     * @param right A packed array such as one produced by pack()
     * @return A packed array that encodes "on" for all cells that were "on" in either left or right
     */
    public static RoaringBitmap unionPacked(RoaringBitmap left, RoaringBitmap right)
    {
        return RoaringBitmap.or(left, right);
    }

    /**
     * Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
     * that was "on" in both left and in right, and encodes "off" for cells that were off in either array. This method
     * does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
     * when finding the intersection of two pieces of packed data.
     * @param left A packed array such as one produced by pack()
     * @param right A packed array such as one produced by pack()
     * @return A packed array that encodes "on" for all cells that were "on" in both left and right
     */
    public static RoaringBitmap intersectPacked(RoaringBitmap left, RoaringBitmap right)
    {
        return RoaringBitmap.and(left, right);
    }

    /**
     * Given one packed short array, this produces a packed short array that is the exact opposite of the one passed in,
     * that is, every "on" cell becomes "off" and every "off" cell becomes "on", including cells that were "off" because
     * they were beyond the boundaries of the original 2D array passed to pack() or a similar method. This method does
     * not do any unpacking (which can be somewhat computationally expensive), and actually requires among the lowest
     * amounts of computation to get a result of any methods in CoordPacker. However, because it will cause cells to be
     * considered "on" that would cause an exception if directly converted to x,y positions and accessed in the source
     * 2D array, this method should primarily be used in conjunction with operations such as intersectPacked(), or have
     * the checking for boundaries handled internally by unpack() or related methods such as unpackMultiDouble().
     * @param original A packed array such as one produced by pack()
     * @return A packed array that encodes "on" all cells that were "off" in original
     */
    public static RoaringBitmap negatePacked(RoaringBitmap original) {
        if (original.getCardinality() == 0) {
            return ALL_ON;
        }
        return RoaringBitmap.flip(original, 0, 65536);
    }

    /**
     * Given two packed short arrays, left and right, this produces a packed short array that encodes "on" for any cell
     * that was "on" in left but "off" in right, and encodes "off" for cells that were "on" in right or "off" in left.
     * This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
     * preferred when finding a region of one packed array that is not contained in another packed array.
     * @param left A packed array such as one produced by pack()
     * @param right A packed array such as one produced by pack()
     * @return A packed array that encodes "on" for all cells that were "on" in left and "off" in right
     */
    public static RoaringBitmap differencePacked(RoaringBitmap left, RoaringBitmap right)
    {
        return RoaringBitmap.andNot(left, right);
    }

    /**
     * Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
     * that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
     * to by hilbert, and encodes "off" for cells that were "off" in original and are not the cell hilbert refers to.
     * This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
     * preferred when finding a region of one packed array that is not contained in another packed array.
     * @param original A packed array such as one produced by pack()
     * @param hilbert A Hilbert Curve index that should be inserted into the result
     * @return A packed array that encodes "on" for all cells that are "on" in original or correspond to hilbert
     */
    public static RoaringBitmap insertPacked(RoaringBitmap original, int hilbert)
    {
        return RoaringBitmap.add(original, hilbert, hilbert + 1);
    }
    /**
     * Given one packed short array, original, and a position as x,y numbers, this produces a packed short array
     * that encodes "on" for any cell that was "on" in original, always encodes "on" for the position referred
     * to by x and y, and encodes "off" for cells that were "off" in original and are not the cell x and y refer to.
     * This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
     * preferred when finding a region of one packed array that is not contained in another packed array.
     * @param original A packed array such as one produced by pack()
     * @param x The x position at which to insert the "on" cell
     * @param y The y position at which to insert the "on" cell
     * @return A packed array that encodes "on" for all cells that are "on" in original or correspond to x,y
     */
    public static RoaringBitmap insertPacked(RoaringBitmap original, int x, int y)
    {
        int hilbert = CoordPacker.posToHilbert(x, y);
        return RoaringBitmap.add(original, hilbert, hilbert + 1);
    }

    /**
     * Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
     * short array that encodes "on" for any cell that was "on" in original, always encodes "on" for the position
     * referred to by any element of hilbert, and encodes "off" for cells that were "off" in original and are not in any
     * cell hilbert refers to. This method does not do any unpacking (which can be somewhat computationally expensive)
     * and so should be strongly preferred when you have several Hilbert Curve indices, possibly nearby each other but
     * just as possibly not, that you need inserted into a packed array.
     * <br>
     *     NOTE: this may not produce an optimally packed result, though the difference in memory consumption is likely
     *     to be exceedingly small unless there are many nearby elements in hilbert (which may be a better use case for
     *     unionPacked() anyway).
     * @param original A packed array such as one produced by pack()
     * @param hilbert an array or vararg of Hilbert Curve indices that should be inserted into the result
     * @return A packed array that encodes "on" for all cells that are "on" in original or are contained in hilbert
     */
    public static RoaringBitmap insertSeveralPacked(RoaringBitmap original, int... hilbert)
    {
        return RoaringBitmap.or(original, RoaringBitmap.bitmapOf(hilbert));
    }
    /**
     * Given one packed short array, original, and a Hilbert Curve index, hilbert, this produces a packed short array
     * that encodes "on" for any cell that was "on" in original, unless it was the position referred to by hilbert, and
     * encodes "off" for cells that were "off" in original or are the cell hilbert refers to.
     * This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
     * preferred when finding a region of one packed array that is not contained in another packed array.
     * @param original A packed array such as one produced by pack()
     * @param hilbert A Hilbert Curve index that should be removed from the result
     * @return A packed array that encodes "on" for all cells that are "on" in original and don't correspond to hilbert
     */
    public static RoaringBitmap removePacked(RoaringBitmap original, int hilbert)
    {
        return RoaringBitmap.remove(original, hilbert, hilbert + 1);
    }
    /**
     * Given one packed short array, original, and a position as x,y numbers, this produces a packed short array that
     * encodes "on" for any cell that was "on" in original, unless it was the position referred to by x and y, and
     * encodes "off" for cells that were "off" in original or are the cell x and y refer to.
     * This method does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly
     * preferred when finding a region of one packed array that is not contained in another packed array.
     * @param original A packed array such as one produced by pack()
     * @param x The x position at which to remove any "on" cell
     * @param y The y position at which to remove any "on" cell
     * @return A packed array that encodes "on" for all cells that are "on" in original and don't correspond to x,y
     */
    public static RoaringBitmap removePacked(RoaringBitmap original, int x, int y)
    {
        int hilbert = CoordPacker.posToHilbert(x, y);
        return RoaringBitmap.remove(original, hilbert, hilbert + 1);
    }

    /**
     * Given one packed short array, original, and a number of Hilbert Curve indices, hilbert, this produces a packed
     * short array that encodes "on" for any cell that was "on" in original, unless it was a position referred to by
     * hilbert, and encodes "off" for cells that were "off" in original and are a cell hilbert refers to. This method
     * does not do any unpacking (which can be somewhat computationally expensive) and so should be strongly preferred
     * when you have several Hilbert Curve indices, possibly nearby each other but just as possibly not, that you need
     * removed from a packed array.
     * <br>
     *     NOTE: this may not produce an optimally packed result, though the difference in memory consumption is likely
     *     to be exceedingly small unless there are many nearby elements in hilbert (which may be a better use case for
     *     differencePacked() anyway).
     * @param original A packed array such as one produced by pack()
     * @param hilbert an array or vararg of Hilbert Curve indices that should be inserted into the result
     * @return A packed array that encodes "on" for all cells that are "on" in original and aren't contained in hilbert
     */
    public static RoaringBitmap removeSeveralPacked(RoaringBitmap original, int... hilbert)
    {
        return RoaringBitmap.andNot(original, RoaringBitmap.bitmapOf(hilbert));
    }

    /**
     * Gets a random subset of positions that are "on" in the given packed array, without unpacking it, and returns
     * them as a Coord[]. Random numbers are generated by the rng parameter.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check).
     * @param fraction the likelihood to return one of the "on" cells, from 0.0 to 1.0
     * @param rng the random number generator used to decide random factors.
     * @return a Coord[], ordered by distance along the Hilbert Curve, corresponding to a random section of "on" cells
     * in packed that has a random length approximately equal to the count of all "on" cells in packed times fraction.
     */
    public static ArrayList<Coord> randomSample(RoaringBitmap packed, double fraction, RNG rng)
    {
        int[] positions = packed.toArray();
        ArrayList<Coord> cs = new ArrayList<Coord>(positions.length);
        for(int i = 0; i < positions.length; i++) {
            if(rng.nextDouble() < fraction)
                cs.add(Coord.get(CoordPacker.hilbertX[positions[i]], CoordPacker.hilbertY[positions[i]]));
        }
        return cs;
    }
    /**
     * Gets a single randomly chosen position that is "on" in the given packed array, without unpacking it, and returns
     * it as a Coord or returns null of the array is empty. Random numbers are generated by the rng parameter.
     * More efficient in most cases than randomSample(), and will always return at least one Coord for non-empty arrays.
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check).
     * @param rng the random number generator used to decide random factors
     * @return a Coord corresponding to a random "on" cell in packed
     */
    public static Coord singleRandom(RoaringBitmap packed, RNG rng)
    {
        int idx = packed.select(rng.nextInt(packed.getCardinality()));
        return Coord.get(CoordPacker.hilbertX[idx], CoordPacker.hilbertY[idx]);
    }

    /**
     * Gets a fixed number of randomly chosen positions that are "on" in the given packed array, without unpacking it,
     * and returns a List of Coord with a count equal to size (or less if there aren't enough "on" cells). Random
     * numbers are generated by the rng parameter. This orders the returned array in the order the Hilbert Curve takes,
     * and you may want to call RNG.shuffle() with it as a parameter to randomize the order.
     *
     * @param packed a short[] returned by pack() or one of the sub-arrays in what is returned by packMulti(); must
     *               not be null (this method does not check).
     * @param size the desired size of the List to return; may be smaller if there aren't enough elements
     * @param rng the random number generator used to decide random factors.
     * @return a List of Coords, ordered by distance along the Hilbert Curve, corresponding to randomly "on" cells in
     * packed, with a length equal to the smaller of size and the count of all "on" cells in packed
     */
    public static ArrayList<Coord> randomPortion(RoaringBitmap packed, int size, RNG rng)
    {
        int counted = packed.getCardinality();
        ArrayList<Coord> coords = new ArrayList<Coord>(Math.min(counted, size));
        if(counted == 0 || size == 0)
            return coords;
        int[] data = rng.randomRange(0, counted, Math.min(counted, size));
        int idx = 0;
        for (int i = 0; i < data.length; i++) {
            idx = packed.select(data[i]);
            coords.add(Coord.get(CoordPacker.hilbertX[idx], CoordPacker.hilbertY[idx]));
        }
        return coords;
    }

    /**
     * Quick utility method for printing packed data as a grid of 1 (on) and/or 0 (off). Useful primarily for debugging.
     * @param packed a packed short[] such as one produced by pack()
     * @param width the width of the packed 2D array
     * @param height the height of the packed 2D array
     */
    public static void printPacked(RoaringBitmap packed, int width, int height)
    {
        boolean[][] unpacked = unpack(packed, width, height);
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                System.out.print(unpacked[x][y] ? '1' : '0');
            }
            System.out.println();
        }
    }
}
