package squidpony.squidmath;

/**
 * Simple hashing functions that we can rely on staying the same between platforms.
 * These return long values instead of int, since they're mainly needed for RNG seeding.
 * The hashes this returns are always 0L when given null to hash. Arrays with identical
 * elements of identical types will hash identically. For empty arrays, the
 * hash this returns is a 64-bit number with exactly 32 bits set in semi-random
 * positions (determined mostly by the sequence of prime numbers under 64).
 * <br>
 * The hash for an empty byte array is 0x5a4936c96936db7L ;
 * The hash for an empty short array is 0xb4926d92d26db6eL ;
 * The hash for an empty int array is 0x16924db25a4db6dcL ;
 * The hash for an empty long array is 0x2d249b64b49b6db8L ;
 * The hash for an empty char array is 0xf4b6d926d2d92492L (which is negative due to overflow).
 * The hash for an empty boolean array is 0xfa5b6c93696c9249L (which is negative due to overflow).
 *
 * Created by Tommy Ettinger on 1/16/2016.
 * @author Tommy Ettinger
 */
/*
 * To be exact, the numbers were generated by this Clojure code, which no one needs to understand to use this class.
 * It is only here so the numbers can be re-generated if need be.
 * (Long/rotateRight
 *            (reduce #(bit-xor %1 (bit-shift-left 9 (dec %2)))
 *                6
 *                [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61])
 *            5)
 * byte arrays use that number verbatim, short arrays use it rotated left by 1, int arrays rotated left by 2,
 * long arrays rotated left by 3, boolean arrays use it bitwise negated, and char arrays use it rotated left by 1
 * and bitwise negated.
 */
public class StableHash {
    public static long hash(boolean[] data)
    {
        long l = 0xfa5b6c93696c9249L;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 64) {
            for (int i = 0, c = 0; c < 64; i = (i + 1) % len, c++) {
                l ^= (data[i] ? 1L : 0L) << c;
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 64, r += (c == 0) ? 1 : 0) {
                l ^= (data[i] ? 1L : 0L) << (c + r);
            }
        }
        return l ^ len;
    }
    public static long hash(byte[] data)
    {
        long l = 0x5a4936c96936db7L;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 16) {
            for (int i = 0, c = 0; c < 16; i = (i + 1) % len, c++) {
                l ^= (long)data[i] << (c * 4);
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 16, r += (c == 0) ? 1 : 0) {
                l ^= (long)data[i] << (c * 4 + r);
            }
        }
        return l ^ len;
    }
    public static long hash(char[] data)
    {
        long l = 0xf4b6d926d2d92492L;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 8) {
            for (int i = 0, c = 0; c < 8; i = (i + 1) % len, c++) {
                l ^= (long)data[i] << (c * 8);
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 8, r += (c == 0) ? 1 : 0) {
                l ^= (long)data[i] << (c * 8 + r);
            }
        }
        return l ^ len;
    }
    public static long hash(short[] data)
    {
        long l = 0xb4926d92d26db6eL;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 8) {
            for (int i = 0, c = 0; c < 8; i = (i + 1) % len, c++) {
                l ^= (long)data[i] << (c * 8);
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 8, r += (c == 0) ? 1 : 0) {
                l ^= (long)data[i] << (c * 8 + r);
            }
        }
        return l ^ len;
    }
    public static long hash(int[] data)
    {
        long l = 0x16924db25a4db6dcL;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 4) {
            for (int i = 0, c = 0; c < 4; i = (i + 1) % len, c++) {
                l ^= (long)data[i] << (c * 16);
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 4, r += (c == 0) ? 1 : 0) {
                l ^= (long)data[i] << (c * 16 + r);
            }
        }
        return l ^ len;
    }
    public static long hash(long[] data)
    {
        long l = 0x2d249b64b49b6db8L;
        if(data == null)
            return 0L;
        int len = data.length;
        if(len <= 4) {
            for (int i = 0, c = 0; c < 4; i = (i + 1) % len, c++) {
                l ^= data[i] << (c * 16);
            }
        }
        else
        {
            for (int i = 0, c = 0, r = 0; i < len; i++, c = (c + 1) % 4, r += (c == 0) ? 1 : 0) {
                l ^= data[i] << (c * 16 + r);
            }
        }
        return l ^ len;
    }
    public static long hash(String s)
    {
        if(s == null)
            return 0L;
        return hash(s.toCharArray());
    }
}
